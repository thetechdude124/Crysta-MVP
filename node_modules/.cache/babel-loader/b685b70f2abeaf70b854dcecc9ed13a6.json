{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.writableServerSelector = void 0;\n\nconst common_1 = require(\"./common\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst error_1 = require(\"../error\"); // max staleness constants\n\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n}\n\nexports.writableServerSelector = writableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return (topologyDescription, servers) => {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":{"version":3,"sources":["../../src/sdam/server_selection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readPreferenceServerSelector = exports.writableServerSelector = void 0;\nconst common_1 = require(\"./common\");\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n    return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));\n}\nexports.writableServerSelector = writableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n        return servers;\n    }\n    const maxStaleness = readPreference.maxStalenessSeconds;\n    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n    if (maxStaleness < maxStalenessVariance) {\n        throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n    }\n    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n        throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n    }\n    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n        return servers.reduce((result, server) => {\n            var _a;\n            const stalenessMS = server.lastUpdateTime -\n                server.lastWriteDate -\n                (primary.lastUpdateTime - primary.lastWriteDate) +\n                topologyDescription.heartbeatFrequencyMS;\n            const staleness = stalenessMS / 1000;\n            const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n            if (staleness <= maxStalenessSeconds) {\n                result.push(server);\n            }\n            return result;\n        }, []);\n    }\n    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n        if (servers.length === 0) {\n            return servers;\n        }\n        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n        return servers.reduce((result, server) => {\n            var _a;\n            const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n            const staleness = stalenessMS / 1000;\n            const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n            if (staleness <= maxStalenessSeconds) {\n                result.push(server);\n            }\n            return result;\n        }, []);\n    }\n    return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n    const keys = Object.keys(tagSet);\n    const serverTagKeys = Object.keys(serverTags);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n    if (readPreference.tags == null ||\n        (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)) {\n        return servers;\n    }\n    for (let i = 0; i < readPreference.tags.length; ++i) {\n        const tagSet = readPreference.tags[i];\n        const serversMatchingTagset = servers.reduce((matched, server) => {\n            if (tagSetMatch(tagSet, server.tags))\n                matched.push(server);\n            return matched;\n        }, []);\n        if (serversMatchingTagset.length) {\n            return serversMatchingTagset;\n        }\n    }\n    return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n    const high = low + topologyDescription.localThresholdMS;\n    return servers.reduce((result, server) => {\n        if (server.roundTripTime <= high && server.roundTripTime >= low)\n            result.push(server);\n        return result;\n    }, []);\n}\n// filters\nfunction primaryFilter(server) {\n    return server.type === common_1.ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n    return server.type === common_1.ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n    return server.type !== common_1.ServerType.Unknown;\n}\nfunction loadBalancerFilter(server) {\n    return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n    if (!readPreference.isValid()) {\n        throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n    }\n    return (topologyDescription, servers) => {\n        const commonWireVersion = topologyDescription.commonWireVersion;\n        if (commonWireVersion &&\n            readPreference.minWireVersion &&\n            readPreference.minWireVersion > commonWireVersion) {\n            throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n        }\n        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n            return servers.filter(loadBalancerFilter);\n        }\n        if (topologyDescription.type === common_1.TopologyType.Unknown) {\n            return [];\n        }\n        if (topologyDescription.type === common_1.TopologyType.Single ||\n            topologyDescription.type === common_1.TopologyType.Sharded) {\n            return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n        }\n        const mode = readPreference.mode;\n        if (mode === read_preference_1.ReadPreference.PRIMARY) {\n            return servers.filter(primaryFilter);\n        }\n        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n            const result = servers.filter(primaryFilter);\n            if (result.length) {\n                return result;\n            }\n        }\n        const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n            return servers.filter(primaryFilter);\n        }\n        return selectedServers;\n    };\n}\nexports.readPreferenceServerSelector = readPreferenceServerSelector;\n//# sourceMappingURL=server_selection.js.map"]},"metadata":{},"sourceType":"script"}