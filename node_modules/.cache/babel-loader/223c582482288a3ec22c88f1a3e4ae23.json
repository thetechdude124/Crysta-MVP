{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnorderedBulkOperation = void 0;\n\nconst BSON = require(\"../bson\");\n\nconst common_1 = require(\"./common\");\n\nconst error_1 = require(\"../error\");\n/** @public */\n\n\nclass UnorderedBulkOperation extends common_1.BulkOperationBase {\n  constructor(collection, options) {\n    super(collection, options, false);\n  }\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n\n  addToOperationsList(batchType, document) {\n    // Get the bsonSize\n    const bsonSize = BSON.calculateObjectSize(document, {\n      checkKeys: false,\n      // Since we don't know what the user selected for BSON options here,\n      // err on the safe side, and check the size with ignoreUndefined: false.\n      ignoreUndefined: false\n    }); // Throw error if the doc is bigger than the max BSON size\n\n    if (bsonSize >= this.s.maxBsonObjectSize) {\n      // TODO(NODE-3483): Change this to MongoBSONError\n      throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);\n    } // Holds the current batch\n\n\n    this.s.currentBatch = undefined; // Get the right type of batch\n\n    if (batchType === common_1.BatchType.INSERT) {\n      this.s.currentBatch = this.s.currentInsertBatch;\n    } else if (batchType === common_1.BatchType.UPDATE) {\n      this.s.currentBatch = this.s.currentUpdateBatch;\n    } else if (batchType === common_1.BatchType.DELETE) {\n      this.s.currentBatch = this.s.currentRemoveBatch;\n    }\n\n    const maxKeySize = this.s.maxKeySize; // Create a new batch object if we don't have a current one\n\n    if (this.s.currentBatch == null) {\n      this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n    } // Check if we need to create a new batch\n\n\n    if ( // New batch if we exceed the max batch op size\n    this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n    this.s.currentBatch.batchType !== batchType) {\n      // Save the batch to the execution stack\n      this.s.batches.push(this.s.currentBatch); // Create a new batch\n\n      this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n    } // We have an array of documents\n\n\n    if (Array.isArray(document)) {\n      throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');\n    }\n\n    this.s.currentBatch.operations.push(document);\n    this.s.currentBatch.originalIndexes.push(this.s.currentIndex);\n    this.s.currentIndex = this.s.currentIndex + 1; // Save back the current Batch to the right type\n\n    if (batchType === common_1.BatchType.INSERT) {\n      this.s.currentInsertBatch = this.s.currentBatch;\n      this.s.bulkResult.insertedIds.push({\n        index: this.s.bulkResult.insertedIds.length,\n        _id: document._id\n      });\n    } else if (batchType === common_1.BatchType.UPDATE) {\n      this.s.currentUpdateBatch = this.s.currentBatch;\n    } else if (batchType === common_1.BatchType.DELETE) {\n      this.s.currentRemoveBatch = this.s.currentBatch;\n    } // Update current batch size\n\n\n    this.s.currentBatch.size += 1;\n    this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\n    return this;\n  }\n\n}\n\nexports.UnorderedBulkOperation = UnorderedBulkOperation;","map":{"version":3,"sources":["../../src/bulk/unordered.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnorderedBulkOperation = void 0;\nconst BSON = require(\"../bson\");\nconst common_1 = require(\"./common\");\nconst error_1 = require(\"../error\");\n/** @public */\nclass UnorderedBulkOperation extends common_1.BulkOperationBase {\n    constructor(collection, options) {\n        super(collection, options, false);\n    }\n    handleWriteError(callback, writeResult) {\n        if (this.s.batches.length) {\n            return false;\n        }\n        return super.handleWriteError(callback, writeResult);\n    }\n    addToOperationsList(batchType, document) {\n        // Get the bsonSize\n        const bsonSize = BSON.calculateObjectSize(document, {\n            checkKeys: false,\n            // Since we don't know what the user selected for BSON options here,\n            // err on the safe side, and check the size with ignoreUndefined: false.\n            ignoreUndefined: false\n        });\n        // Throw error if the doc is bigger than the max BSON size\n        if (bsonSize >= this.s.maxBsonObjectSize) {\n            // TODO(NODE-3483): Change this to MongoBSONError\n            throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);\n        }\n        // Holds the current batch\n        this.s.currentBatch = undefined;\n        // Get the right type of batch\n        if (batchType === common_1.BatchType.INSERT) {\n            this.s.currentBatch = this.s.currentInsertBatch;\n        }\n        else if (batchType === common_1.BatchType.UPDATE) {\n            this.s.currentBatch = this.s.currentUpdateBatch;\n        }\n        else if (batchType === common_1.BatchType.DELETE) {\n            this.s.currentBatch = this.s.currentRemoveBatch;\n        }\n        const maxKeySize = this.s.maxKeySize;\n        // Create a new batch object if we don't have a current one\n        if (this.s.currentBatch == null) {\n            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n        }\n        // Check if we need to create a new batch\n        if (\n        // New batch if we exceed the max batch op size\n        this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize ||\n            // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n            // since we can't sent an empty batch\n            (this.s.currentBatch.size > 0 &&\n                this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes) ||\n            // New batch if the new op does not have the same op type as the current batch\n            this.s.currentBatch.batchType !== batchType) {\n            // Save the batch to the execution stack\n            this.s.batches.push(this.s.currentBatch);\n            // Create a new batch\n            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n        }\n        // We have an array of documents\n        if (Array.isArray(document)) {\n            throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');\n        }\n        this.s.currentBatch.operations.push(document);\n        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);\n        this.s.currentIndex = this.s.currentIndex + 1;\n        // Save back the current Batch to the right type\n        if (batchType === common_1.BatchType.INSERT) {\n            this.s.currentInsertBatch = this.s.currentBatch;\n            this.s.bulkResult.insertedIds.push({\n                index: this.s.bulkResult.insertedIds.length,\n                _id: document._id\n            });\n        }\n        else if (batchType === common_1.BatchType.UPDATE) {\n            this.s.currentUpdateBatch = this.s.currentBatch;\n        }\n        else if (batchType === common_1.BatchType.DELETE) {\n            this.s.currentRemoveBatch = this.s.currentBatch;\n        }\n        // Update current batch size\n        this.s.currentBatch.size += 1;\n        this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\n        return this;\n    }\n}\nexports.UnorderedBulkOperation = UnorderedBulkOperation;\n//# sourceMappingURL=unordered.js.map"]},"metadata":{},"sourceType":"script"}