{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.APM_EVENTS = exports.Connection = void 0;\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst error_1 = require(\"../error\");\n\nconst commands_1 = require(\"./commands\");\n\nconst bson_1 = require(\"../bson\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = utils_1.now(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.ismaster) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    })); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.ismaster) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return utils_1.calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = utils_1.now();\n  }\n\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.ismaster == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  /** @internal */\n\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = shared_1.getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = sessions_1.applySession(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (shared_1.isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      slaveOk: readPreference.slaveOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n  /** @internal */\n\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      slaveOk: readPreference.slaveOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...bson_1.pluckBSONSerializeOptions(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n  /** @internal */\n\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = utils_1.maxWireVersion(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = shared_1.applyCommonQueryOptions({}, Object.assign(options, { ...bson_1.pluckBSONSerializeOptions(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  /** @internal */\n\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if (utils_1.maxWireVersion(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = 'commandStarted';\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = 'commandSucceeded';\n/** @event */\n\nConnection.COMMAND_FAILED = 'commandFailed';\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';\n/** @event */\n\nConnection.CLOSE = 'close';\n/** @event */\n\nConnection.MESSAGE = 'message';\n/** @event */\n\nConnection.PINNED = 'pinned';\n/** @event */\n\nConnection.UNPINNED = 'unpinned';\n/** @public */\n\nexports.APM_EVENTS = [Connection.COMMAND_STARTED, Connection.COMMAND_SUCCEEDED, Connection.COMMAND_FAILED];\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = utils_1.maxWireVersion(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return utils_1.maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        sessions_1.updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return utils_1.uuidV4().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = utils_1.now();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"sources":["../../src/cmap/connection.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,MAAA,2BAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;AAKA,MAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAUA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AASA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAUA,MAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAIA,MAAA,QAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGA,MAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAEA;;;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,QAAD,CAAtB;AACA;;AACA,MAAM,MAAM,GAAG,MAAM,CAAC,OAAD,CAArB;AACA;;AACA,MAAM,cAAc,GAAG,MAAM,CAAC,eAAD,CAA7B;AACA;;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,YAAD,CAA1B;AACA;;AACA,MAAM,YAAY,GAAG,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAM,YAAY,GAAG,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAM,YAAY,GAAG,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,UAAD,CAAxB;AACA;;AACA,MAAM,cAAc,GAAG,MAAM,CAAC,eAAD,CAA7B;AACA;;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,YAAD,CAA1B;AA6FA;;AACA,MAAa,UAAb,SAAgC,aAAA,CAAA,iBAAhC,CAAmE;AA4CjE,EAAA,WAAA,CAAY,MAAZ,EAA4B,OAA5B,EAAsD;;;AACpD;AACA,SAAK,EAAL,GAAU,OAAO,CAAC,EAAlB;AACA,SAAK,OAAL,GAAe,gBAAgB,CAAC,MAAD,CAA/B;AACA,SAAK,eAAL,GAAuB,CAAA,EAAA,GAAA,OAAO,CAAC,eAAR,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,EAAvB,GAA2B,CAAlD;AACA,SAAK,eAAL,GAAuB,OAAO,CAAC,eAA/B;AACA,SAAK,SAAL,GAAiB,OAAO,CAAC,SAAzB;AACA,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,SAAL,GAAiB,KAAjB;AAEA,SAAK,YAAL,IAAqB,IAAI,oBAAA,CAAA,iBAAJ,CAAsB,KAAK,OAA3B,EAAoC,OAApC,CAArB;AACA,SAAK,WAAL,IAAoB,OAAO,CAAC,UAA5B;AACA,SAAK,YAAL,IAAqB,OAAA,CAAA,GAAA,EAArB,CAZoD,CAcpD;;AACA,SAAK,MAAL,IAAe,IAAI,GAAJ,EAAf;AACA,SAAK,cAAL,IAAuB,IAAI,gBAAA,CAAA,aAAJ,CAAkB,EACvC,GAAG,OADoC;AAEvC,MAAA,kBAAkB,EAAE,CAAA,EAAA,GAAA,KAAK,QAAL,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAE;AAFI,KAAlB,CAAvB;AAIA,SAAK,cAAL,EAAqB,EAArB,CAAwB,SAAxB,EAAmC,cAAc,CAAC,IAAD,CAAjD;AACA,SAAK,OAAL,IAAgB,MAAhB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,MAAK;AACtB;AACD,KAFD;AAIA,SAAK,cAAL,EAAqB,EAArB,CAAwB,OAAxB,EAAiC,KAAK,IAAI,KAAK,WAAL,CAAiB;AAAE,MAAA,OAAO,EAAE;AAAX,KAAjB,CAA1C;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,MAAM,KAAK,WAAL,CAAiB;AAAE,MAAA,OAAO,EAAE;AAAX,KAAjB,CAAzB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,SAAV,EAAqB,MAAM,KAAK,WAAL,CAAiB;AAAE,MAAA,SAAS,EAAE,IAAb;AAAmB,MAAA,OAAO,EAAE;AAA5B,KAAjB,CAA3B,EA5BoD,CA8BpD;;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,cAAL,CAAZ;AACA,SAAK,cAAL,EAAqB,IAArB,CAA0B,MAA1B;AACD;;AAEc,MAAX,WAAW,GAAA;AACb,WAAO,KAAK,YAAL,CAAP;AACD;;AAEW,MAAR,QAAQ,GAAA;AACV,WAAO,KAAK,SAAL,CAAP;AACD,GArFgE,CAuFjE;;;AACY,MAAR,QAAQ,CAAC,QAAD,EAAmB;AAC7B,SAAK,YAAL,EAAmB,eAAnB,CAAmC,QAAnC;AACA,SAAK,YAAL,IAAqB,MAAM,CAAC,MAAP,CAAc,KAAK,YAAL,CAAd,CAArB,CAF6B,CAI7B;;AACA,SAAK,SAAL,IAAkB,QAAlB;AACD;;AAEY,MAAT,SAAS,GAAA;;;AACX,WAAO,CAAA,EAAA,GAAA,KAAK,QAAL,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAE,SAAtB;AACD;;AAEe,MAAZ,YAAY,GAAA;AACd,WAAO,KAAK,WAAL,CAAiB,YAAxB;AACD;;AAEa,MAAV,UAAU,GAAA;AACZ,WAAO,KAAK,WAAL,KAAqB,CAA5B;AACD;;AAEa,MAAV,UAAU,CAAC,UAAD,EAAmB;AAC/B,SAAK,WAAL,IAAoB,UAApB;AACD;;AAEW,MAAR,QAAQ,GAAA;AACV,WAAO,OAAA,CAAA,qBAAA,CAAsB,KAAK,YAAL,CAAtB,CAAP;AACD;;AAEc,MAAX,WAAW,GAAA;AACb,WAAO,KAAK,YAAL,CAAP;AACD;;AAES,MAAN,MAAM,GAAA;AACR,WAAO,KAAK,OAAL,CAAP;AACD;;AAED,EAAA,aAAa,GAAA;AACX,SAAK,YAAL,IAAqB,OAAA,CAAA,GAAA,EAArB;AACD;;AAED,EAAA,WAAW,CAAC,KAAD,EAA6E;AACtF,QAAI,KAAK,MAAT,EAAiB;AACf;AACD;;AAED,QAAI,KAAK,CAAC,OAAV,EAAmB;AACjB,WAAK,OAAL,EAAc,OAAd,CAAsB,OAAO,KAAK,CAAC,OAAb,KAAyB,SAAzB,GAAqC,SAArC,GAAiD,KAAK,CAAC,OAA7E;AACD;;AAED,SAAK,MAAL,GAAc,IAAd;;AAEA,SAAK,MAAM,GAAG,EAAH,CAAX,IAAqB,KAAK,MAAL,CAArB,EAAmC;AACjC,UAAI,KAAK,CAAC,SAAV,EAAqB;AACnB,QAAA,EAAE,CAAC,EAAH,CACE,IAAI,OAAA,CAAA,wBAAJ,CAA6B,cAAc,KAAK,EAAE,OAAO,KAAK,OAAO,YAArE,EAAmF;AACjF,UAAA,eAAe,EAAE,KAAK,QAAL,IAAiB;AAD+C,SAAnF,CADF;AAKD,OAND,MAMO,IAAI,KAAK,CAAC,OAAV,EAAmB;AACxB,QAAA,EAAE,CAAC,EAAH,CAAM,IAAI,OAAA,CAAA,iBAAJ,CAAsB,cAAc,KAAK,EAAE,OAAO,KAAK,OAAO,SAA9D,CAAN;AACD,OAFM,MAEA;AACL,QAAA,EAAE,CAAC,EAAH,CAAM,OAAO,KAAK,CAAC,OAAb,KAAyB,SAAzB,GAAqC,SAArC,GAAiD,KAAK,CAAC,OAA7D;AACD;AACF;;AAED,SAAK,MAAL,EAAa,KAAb;AACA,SAAK,IAAL,CAAU,UAAU,CAAC,KAArB;AACD;;AAMD,EAAA,OAAO,CAAC,OAAD,EAAsC,QAAtC,EAAyD;AAC9D,QAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,MAAA,QAAQ,GAAG,OAAX;AACA,MAAA,OAAO,GAAG;AAAE,QAAA,KAAK,EAAE;AAAT,OAAV;AACD;;AAED,SAAK,kBAAL,CAAwB,UAAU,CAAC,MAAnC;AACA,SAAK,kBAAL,CAAwB,UAAU,CAAC,QAAnC;AAEA,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc;AAAE,MAAA,KAAK,EAAE;AAAT,KAAd,EAAgC,OAAhC,CAAV;;AACA,QAAI,KAAK,OAAL,KAAiB,IAAjB,IAAyB,KAAK,SAAlC,EAA6C;AAC3C,WAAK,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAA,QAAQ;AACT;;AAED;AACD;;AAED,QAAI,OAAO,CAAC,KAAZ,EAAmB;AACjB,WAAK,OAAL,EAAc,OAAd;AACA,WAAK,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAA,QAAQ;AACT;;AAED;AACD;;AAED,SAAK,OAAL,EAAc,GAAd,CAAkB,MAAK;AACrB,WAAK,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAA,QAAQ;AACT;AACF,KALD;AAMD;AAED;;;AACA,EAAA,OAAO,CACL,EADK,EAEL,GAFK,EAGL,OAHK,EAIL,QAJK,EAIa;AAElB,QAAI,EAAE,EAAE,YAAY,OAAA,CAAA,gBAAhB,CAAJ,EAAuC;AACrC;AACA,YAAM,IAAI,OAAA,CAAA,iBAAJ,CAAsB,0CAAtB,CAAN;AACD;;AAED,UAAM,cAAc,GAAG,QAAA,CAAA,iBAAA,CAAkB,GAAlB,EAAuB,OAAvB,CAAvB;AACA,UAAM,cAAc,GAAG,aAAa,CAAC,IAAD,CAApC;AACA,UAAM,OAAO,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,OAAzB;AAEA,QAAI,WAAW,GAAG,KAAK,WAAvB;AACA,QAAI,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,GAAlB,CAAf;;AAEA,QAAI,KAAK,SAAT,EAAoB;AAClB,YAAM;AAAE,QAAA,OAAF;AAAW,QAAA,MAAX;AAAmB,QAAA;AAAnB,UAAyC,KAAK,SAApD;AACA,MAAA,QAAQ,CAAC,UAAT,GAAsB,OAAtB;AACA,UAAI,MAAM,IAAI,IAAd,EAAoB,QAAQ,CAAC,SAAT,GAAqB,MAArB;AACpB,UAAI,iBAAiB,IAAI,IAAzB,EAA+B,QAAQ,CAAC,oBAAT,GAAgC,iBAAhC;AAChC;;AAED,QAAI,iBAAiB,CAAC,IAAD,CAAjB,IAA2B,OAA/B,EAAwC;AACtC,UACE,OAAO,CAAC,WAAR,IACA,WADA,IAEA,OAAO,CAAC,WAAR,CAAoB,WAApB,CAAgC,WAAhC,CAA4C,WAAW,CAAC,WAAxD,CAHF,EAIE;AACA,QAAA,WAAW,GAAG,OAAO,CAAC,WAAtB;AACD;;AAED,YAAM,GAAG,GAAG,UAAA,CAAA,YAAA,CAAa,OAAb,EAAsB,QAAtB,EAAgC,OAAhC,CAAZ;;AACA,UAAI,GAAJ,EAAS;AACP,eAAO,QAAQ,CAAC,GAAD,CAAf;AACD;AACF,KAlCiB,CAoClB;;;AACA,QAAI,WAAJ,EAAiB;AACf,MAAA,QAAQ,CAAC,YAAT,GAAwB,WAAxB;AACD;;AAED,QAAI,QAAA,CAAA,SAAA,CAAU,IAAV,KAAmB,CAAC,cAApB,IAAsC,cAAtC,IAAwD,cAAc,CAAC,IAAf,KAAwB,SAApF,EAA+F;AAC7F,MAAA,QAAQ,GAAG;AACT,QAAA,MAAM,EAAE,QADC;AAET,QAAA,eAAe,EAAE,cAAc,CAAC,MAAf;AAFR,OAAX;AAID;;AAED,UAAM,cAAc,GAAa,MAAM,CAAC,MAAP,CAC/B;AACE,MAAA,OAAO,EAAE,IADX;AAEE,MAAA,YAAY,EAAE,CAFhB;AAGE,MAAA,cAAc,EAAE,CAAC,CAHnB;AAIE,MAAA,SAAS,EAAE,KAJb;AAKE;AACA,MAAA,OAAO,EAAE,cAAc,CAAC,OAAf;AANX,KAD+B,EAS/B,OAT+B,CAAjC;AAYA,UAAM,KAAK,GAAG,GAAG,EAAE,CAAC,EAAE,OAAtB;AACA,UAAM,OAAO,GAAG,cAAc,GAC1B,IAAI,UAAA,CAAA,GAAJ,CAAQ,KAAR,EAAe,QAAf,EAAyB,cAAzB,CAD0B,GAE1B,IAAI,UAAA,CAAA,KAAJ,CAAU,KAAV,EAAiB,QAAjB,EAA2B,cAA3B,CAFJ;;AAIA,QAAI;AACF,MAAA,KAAK,CAAC,IAAD,EAAO,OAAP,EAAgB,cAAhB,EAAgC,QAAhC,CAAL;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,MAAA,QAAQ,CAAC,GAAD,CAAR;AACD;AACF;AAED;;;AACA,EAAA,KAAK,CAAC,EAAD,EAAuB,GAAvB,EAAsC,OAAtC,EAA6D,QAA7D,EAA+E;;;AAClF,UAAM,SAAS,GAAG,GAAG,CAAC,QAAJ,IAAgB,IAAlC;AACA,UAAM,cAAc,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,cAAR,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,EAAtB,GAA0B,iBAAA,CAAA,cAAA,CAAe,OAAhE;AACA,UAAM,SAAS,GAAG,OAAO,CAAC,SAAR,IAAqB,CAAvC;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,KAAtB;AACA,UAAM,YAAY,GAAG,OAAO,CAAC,IAAR,IAAgB,CAArC;AACA,QAAI,cAAc,GAAG,CAArB;;AACA,QACE,KAAK,KACJ,KAAK,GAAG,CAAR,IAAc,KAAK,KAAK,CAAV,IAAe,KAAK,GAAG,SAArC,IAAoD,KAAK,GAAG,CAAR,IAAa,SAAS,KAAK,CAD3E,CADP,EAGE;AACA,MAAA,cAAc,GAAG,KAAjB;AACD,KALD,MAKO;AACL,MAAA,cAAc,GAAG,SAAjB;AACD;;AAED,QAAI,SAAJ,EAAe;AACb;AACA;AACA,MAAA,cAAc,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,KAAK,IAAI,CAAlB,CAAlB;AACD;;AAED,UAAM,YAAY,GAAmB;AACnC,MAAA,YADmC;AAEnC,MAAA,cAFmC;AAGnC,MAAA,UAAU,EAAE,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,SAHb;AAInC,MAAA,SAAS,EAAE,KAJwB;AAKnC,MAAA,OAAO,EAAE,cAAc,CAAC,OAAf;AAL0B,KAArC;;AAQA,QAAI,OAAO,CAAC,UAAZ,EAAwB;AACtB,MAAA,YAAY,CAAC,mBAAb,GAAmC,OAAO,CAAC,UAA3C;AACD;;AAED,UAAM,KAAK,GAAG,IAAI,UAAA,CAAA,KAAJ,CAAU,EAAE,CAAC,QAAH,EAAV,EAAyB,GAAzB,EAA8B,YAA9B,CAAd;;AACA,QAAI,OAAO,OAAO,CAAC,QAAf,KAA4B,SAAhC,EAA2C;AACzC,MAAA,KAAK,CAAC,QAAN,GAAiB,OAAO,CAAC,QAAzB;AACD;;AAED,QAAI,OAAO,OAAO,CAAC,WAAf,KAA+B,SAAnC,EAA8C;AAC5C,MAAA,KAAK,CAAC,WAAN,GAAoB,OAAO,CAAC,WAA5B;AACD;;AAED,QAAI,OAAO,OAAO,CAAC,OAAf,KAA2B,SAA/B,EAA0C;AACxC,MAAA,KAAK,CAAC,eAAN,GAAwB,CAAC,OAAO,CAAC,OAAjC;AACD,KAFD,MAEO,IAAI,OAAO,OAAO,CAAC,eAAf,KAAmC,SAAvC,EAAkD;AACvD,MAAA,KAAK,CAAC,eAAN,GAAwB,OAAO,CAAC,eAAhC;AACD;;AAED,QAAI,OAAO,OAAO,CAAC,SAAf,KAA6B,SAAjC,EAA4C;AAC1C,MAAA,KAAK,CAAC,SAAN,GAAkB,OAAO,CAAC,SAA1B;AACD;;AAED,QAAI,OAAO,OAAO,CAAC,OAAf,KAA2B,SAA/B,EAA0C;AACxC,MAAA,KAAK,CAAC,OAAN,GAAgB,OAAO,CAAC,OAAxB;AACD;;AAED,IAAA,KAAK,CACH,IADG,EAEH,KAFG,EAGH;AAAE,OAAC,WAAD,GAAe,IAAjB;AAAuB,SAAG,MAAA,CAAA,yBAAA,CAA0B,OAA1B;AAA1B,KAHG,EAIH,CAAC,GAAD,EAAM,MAAN,KAAgB;AACd,UAAI,GAAG,IAAI,CAAC,MAAZ,EAAoB,OAAO,QAAQ,CAAC,GAAD,EAAM,MAAN,CAAf;;AACpB,UAAI,SAAS,IAAI,MAAM,CAAC,SAApB,IAAiC,MAAM,CAAC,SAAP,CAAiB,CAAjB,CAArC,EAA0D;AACxD,eAAO,QAAQ,CAAC,SAAD,EAAY,MAAM,CAAC,SAAP,CAAiB,CAAjB,CAAZ,CAAf;AACD;;AAED,MAAA,QAAQ,CAAC,SAAD,EAAY,MAAZ,CAAR;AACD,KAXE,CAAL;AAaD;AAED;;;AACA,EAAA,OAAO,CACL,EADK,EAEL,QAFK,EAGL,OAHK,EAIL,QAJK,EAIuB;AAE5B,UAAM,UAAU,GAAG,CAAC,CAAC,OAAO,CAAC,WAAD,CAA5B;AACA,UAAM,WAAW,GAAG,OAAA,CAAA,cAAA,CAAe,IAAf,CAApB;;AACA,QAAI,CAAC,QAAL,EAAe;AACb;AACA,MAAA,QAAQ,CAAC,IAAI,OAAA,CAAA,iBAAJ,CAAsB,mDAAtB,CAAD,CAAR;AACA;AACD;;AAED,QAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAM,SAAS,GAAG,IAAI,UAAA,CAAA,OAAJ,CAAY,EAAE,CAAC,QAAH,EAAZ,EAA2B,QAA3B,EAAqC;AAAE,QAAA,cAAc,EAAE,OAAO,CAAC;AAA1B,OAArC,CAAlB;AACA,YAAM,YAAY,GAAG,QAAA,CAAA,uBAAA,CACnB,EADmB,EAEnB,MAAM,CAAC,MAAP,CAAc,OAAd,EAAuB,EAAE,GAAG,MAAA,CAAA,yBAAA,CAA0B,OAA1B;AAAL,OAAvB,CAFmB,CAArB;AAKA,MAAA,YAAY,CAAC,WAAD,CAAZ,GAA4B,IAA5B;AACA,MAAA,YAAY,CAAC,OAAb,GAAuB,IAAvB;AACA,MAAA,KAAK,CAAC,IAAD,EAAO,SAAP,EAAkB,YAAlB,EAAgC,CAAC,GAAD,EAAM,QAAN,KAAkB;AACrD,YAAI,UAAJ,EAAgB,OAAO,QAAQ,CAAC,GAAD,EAAM,QAAN,CAAf;AAChB,YAAI,GAAJ,EAAS,OAAO,QAAQ,CAAC,GAAD,CAAf;AACT,QAAA,QAAQ,CAAC,SAAD,EAAY;AAAE,UAAA,MAAM,EAAE;AAAE,YAAA,EAAE,EAAE,QAAQ,CAAC,QAAf;AAAyB,YAAA,SAAS,EAAE,QAAQ,CAAC;AAA7C;AAAV,SAAZ,CAAR;AACD,OAJI,CAAL;AAMA;AACD;;AAED,UAAM,UAAU,GAAa;AAC3B,MAAA,OAAO,EAAE,QADkB;AAE3B,MAAA,UAAU,EAAE,EAAE,CAAC;AAFY,KAA7B;;AAKA,QAAI,OAAO,OAAO,CAAC,SAAf,KAA6B,QAAjC,EAA2C;AACzC,MAAA,UAAU,CAAC,SAAX,GAAuB,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,SAAjB,CAAvB;AACD;;AAED,QAAI,OAAO,OAAO,CAAC,cAAf,KAAkC,QAAtC,EAAgD;AAC9C,MAAA,UAAU,CAAC,SAAX,GAAuB,OAAO,CAAC,cAA/B;AACD;;AAED,UAAM,cAAc,GAAG,MAAM,CAAC,MAAP,CACrB;AACE,MAAA,mBAAmB,EAAE,IADvB;AAEE,MAAA,mBAAmB,EAAE;AAFvB,KADqB,EAKrB,OALqB,CAAvB;AAQA,SAAK,OAAL,CAAa,EAAb,EAAiB,UAAjB,EAA6B,cAA7B,EAA6C,QAA7C;AACD;AAED;;;AACA,EAAA,WAAW,CACT,EADS,EAET,SAFS,EAGT,OAHS,EAIT,QAJS,EAIS;AAElB,QAAI,CAAC,SAAD,IAAc,CAAC,KAAK,CAAC,OAAN,CAAc,SAAd,CAAnB,EAA6C;AAC3C;AACA,YAAM,IAAI,OAAA,CAAA,iBAAJ,CAAsB,wCAAwC,SAAS,EAAvE,CAAN;AACD;;AAED,QAAI,OAAA,CAAA,cAAA,CAAe,IAAf,IAAuB,CAA3B,EAA8B;AAC5B,UAAI;AACF,QAAA,KAAK,CACH,IADG,EAEH,IAAI,UAAA,CAAA,UAAJ,CAAe,EAAE,CAAC,QAAH,EAAf,EAA8B,SAA9B,CAFG,EAGH;AAAE,UAAA,UAAU,EAAE,IAAd;AAAoB,aAAG;AAAvB,SAHG,EAIH,QAJG,CAAL;AAMD,OAPD,CAOE,OAAO,GAAP,EAAY;AACZ,QAAA,QAAQ,CAAC,GAAD,CAAR;AACD;;AAED;AACD;;AAED,SAAK,OAAL,CACE,EADF,EAEE;AAAE,MAAA,WAAW,EAAE,EAAE,CAAC,UAAlB;AAA8B,MAAA,OAAO,EAAE;AAAvC,KAFF,EAGE;AAAE,OAAC,WAAD,GAAe,IAAjB;AAAuB,SAAG;AAA1B,KAHF,EAIE,CAAC,GAAD,EAAM,QAAN,KAAkB;AAChB,UAAI,GAAG,IAAI,CAAC,QAAZ,EAAsB,OAAO,QAAQ,CAAC,GAAD,CAAf;;AACtB,UAAI,QAAQ,CAAC,cAAb,EAA6B;AAC3B,eAAO,QAAQ,CAAC,IAAI,OAAA,CAAA,iBAAJ,CAAsB,4BAAtB,CAAD,EAAsD,IAAtD,CAAf;AACD;;AAED,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,QAAQ,CAAC,SAAvB,CAAD,IAAsC,QAAQ,CAAC,SAAT,CAAmB,MAAnB,KAA8B,CAAxE,EAA2E;AACzE,eAAO,QAAQ,EACb;AACA,YAAI,OAAA,CAAA,iBAAJ,CACE,qDAAqD,SAAS,CAAC,CAAD,CAAG,EADnE,CAFa,CAAf;AAMD;;AAED,MAAA,QAAQ,CAAC,SAAD,EAAY,QAAQ,CAAC,SAAT,CAAmB,CAAnB,CAAZ,CAAR;AACD,KApBH;AAsBD;;AAtcgE;;AAAnE,OAAA,CAAA,UAAA,GAAA,UAAA;AA2BE;;AACgB,UAAA,CAAA,eAAA,GAAkB,gBAAlB;AAChB;;AACgB,UAAA,CAAA,iBAAA,GAAoB,kBAApB;AAChB;;AACgB,UAAA,CAAA,cAAA,GAAiB,eAAjB;AAChB;;AACgB,UAAA,CAAA,qBAAA,GAAwB,qBAAxB;AAChB;;AACgB,UAAA,CAAA,KAAA,GAAQ,OAAR;AAChB;;AACgB,UAAA,CAAA,OAAA,GAAU,SAAV;AAChB;;AACgB,UAAA,CAAA,MAAA,GAAS,QAAT;AAChB;;AACgB,UAAA,CAAA,QAAA,GAAW,UAAX;AA+ZlB;;AACa,OAAA,CAAA,UAAA,GAAa,CACxB,UAAU,CAAC,eADa,EAExB,UAAU,CAAC,iBAFa,EAGxB,UAAU,CAAC,cAHa,CAAb;AAMb;;AACA,MAAa,gBAAb,SAAsC,UAAtC,CAAgD;AAI9C,EAAA,WAAA,CAAY,MAAZ,EAA4B,OAA5B,EAAsD;AACpD,UAAM,MAAN,EAAc,OAAd;AACA,SAAK,cAAL,IAAuB,OAAO,CAAC,aAA/B;AACD;AAED;;;AACA,EAAA,OAAO,CAAC,EAAD,EAAuB,GAAvB,EAAsC,OAAtC,EAA+D,QAA/D,EAAiF;AACtF,UAAM,aAAa,GAAG,KAAK,cAAL,CAAtB;;AACA,QAAI,CAAC,aAAL,EAAoB;AAClB,aAAO,QAAQ,CAAC,IAAI,OAAA,CAAA,2BAAJ,CAAgC,2CAAhC,CAAD,CAAf;AACD;;AAED,UAAM,iBAAiB,GAAG,OAAA,CAAA,cAAA,CAAe,IAAf,CAA1B;;AACA,QAAI,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B;AACA,aAAO,MAAM,OAAN,CAAc,EAAd,EAAkB,GAAlB,EAAuB,OAAvB,EAAgC,QAAhC,CAAP;AACD;;AAED,QAAI,iBAAiB,GAAG,CAAxB,EAA2B;AACzB,MAAA,QAAQ,CACN,IAAI,OAAA,CAAA,uBAAJ,CAA4B,2DAA5B,CADM,CAAR;AAGA;AACD;;AAED,IAAA,aAAa,CAAC,OAAd,CAAsB,EAAE,CAAC,QAAH,EAAtB,EAAqC,GAArC,EAA0C,OAA1C,EAAmD,CAAC,GAAD,EAAM,SAAN,KAAmB;AACpE,UAAI,GAAG,IAAI,SAAS,IAAI,IAAxB,EAA8B;AAC5B,QAAA,QAAQ,CAAC,GAAD,EAAM,IAAN,CAAR;AACA;AACD;;AAED,YAAM,OAAN,CAAc,EAAd,EAAkB,SAAlB,EAA6B,OAA7B,EAAsC,CAAC,GAAD,EAAM,QAAN,KAAkB;AACtD,YAAI,GAAG,IAAI,QAAQ,IAAI,IAAvB,EAA6B;AAC3B,UAAA,QAAQ,CAAC,GAAD,EAAM,QAAN,CAAR;AACA;AACD;;AAED,QAAA,aAAa,CAAC,OAAd,CAAsB,QAAtB,EAAgC,OAAhC,EAAyC,QAAzC;AACD,OAPD;AAQD,KAdD;AAeD;;AA5C6C;;AAAhD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AA+CA;;AACA,SAAgB,iBAAhB,CAAkC,IAAlC,EAAkD;AAChD,QAAM,WAAW,GAAG,IAAI,CAAC,WAAzB;AACA,SAAO,WAAW,CAAC,4BAAZ,IAA4C,IAA5C,IAAoD,CAAC,CAAC,WAAW,CAAC,YAAzE;AACD;;AAHD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAKA,SAAS,aAAT,CAAuB,IAAvB,EAAuC;AACrC,QAAM,WAAW,GAAG,IAAI,CAAC,WAAzB;;AACA,MAAI,WAAW,IAAI,IAAnB,EAAyB;AACvB,WAAO,KAAP;AACD;;AAED,SAAO,OAAA,CAAA,cAAA,CAAe,IAAf,KAAwB,CAAxB,IAA6B,CAAC,WAAW,CAAC,sBAAjD;AACD;;AAED,SAAS,cAAT,CAAwB,IAAxB,EAAwC;AACtC,SAAO,SAAS,cAAT,CAAwB,OAAxB,EAAkD;AACvD;AACA,IAAA,IAAI,CAAC,IAAL,CAAU,SAAV,EAAqB,OAArB;AACA,UAAM,oBAAoB,GAAG,IAAI,CAAC,MAAD,CAAJ,CAAa,GAAb,CAAiB,OAAO,CAAC,UAAzB,CAA7B;;AACA,QAAI,CAAC,oBAAL,EAA2B;AACzB;AACD;;AAED,UAAM,QAAQ,GAAG,oBAAoB,CAAC,EAAtC,CARuD,CAUvD;AACA;AACA;;AACA,IAAA,IAAI,CAAC,MAAD,CAAJ,CAAa,MAAb,CAAoB,OAAO,CAAC,UAA5B;;AACA,QAAI,gBAAgB,OAAhB,IAA2B,OAAO,CAAC,UAAvC,EAAmD;AACjD;AACA,MAAA,IAAI,CAAC,MAAD,CAAJ,CAAa,GAAb,CAAiB,OAAO,CAAC,SAAzB,EAAoC,oBAApC;AACD,KAHD,MAGO,IAAI,oBAAoB,CAAC,qBAAzB,EAAgD;AACrD,MAAA,IAAI,CAAC,OAAD,CAAJ,CAAc,UAAd,CAAyB,IAAI,CAAC,eAA9B;AACD;;AAED,QAAI;AACF;AACA,MAAA,OAAO,CAAC,KAAR,CAAc,oBAAd;AACD,KAHD,CAGE,OAAO,GAAP,EAAY;AACZ;AACA;AACA;AACA,MAAA,QAAQ,CAAC,GAAD,CAAR;AACA;AACD;;AAED,QAAI,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAAJ,EAA0B;AACxB,YAAM,QAAQ,GAAa,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAA3B;AACA,YAAM,OAAO,GAAG,oBAAoB,CAAC,OAArC;;AACA,UAAI,OAAJ,EAAa;AACX,QAAA,UAAA,CAAA,yBAAA,CAA0B,OAA1B,EAAmC,QAAnC;AACD;;AAED,UAAI,QAAQ,CAAC,YAAb,EAA2B;AACzB,QAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,QAAQ,CAAC,YAA9B;AACA,QAAA,IAAI,CAAC,IAAL,CAAU,UAAU,CAAC,qBAArB,EAA4C,QAAQ,CAAC,YAArD;AACD;;AAED,UAAI,oBAAoB,CAAC,OAAzB,EAAkC;AAChC,YAAI,QAAQ,CAAC,iBAAb,EAAgC;AAC9B,UAAA,QAAQ,CAAC,IAAI,OAAA,CAAA,sBAAJ,CAA2B,QAAQ,CAAC,iBAApC,EAAuD,QAAvD,CAAD,CAAR;AACA;AACD;;AAED,YAAI,QAAQ,CAAC,EAAT,KAAgB,CAAhB,IAAqB,QAAQ,CAAC,IAA9B,IAAsC,QAAQ,CAAC,MAA/C,IAAyD,QAAQ,CAAC,IAAtE,EAA4E;AAC1E,UAAA,QAAQ,CAAC,IAAI,OAAA,CAAA,gBAAJ,CAAqB,QAArB,CAAD,CAAR;AACA;AACD;AACF,OAVD,MAUO;AACL;AACA,YAAI,QAAQ,CAAC,EAAT,KAAgB,CAAhB,IAAqB,QAAQ,CAAC,IAA9B,IAAsC,QAAQ,CAAC,MAAnD,EAA2D;AACzD,UAAA,QAAQ,CAAC,IAAI,OAAA,CAAA,gBAAJ,CAAqB,QAArB,CAAD,CAAR;AACA;AACD;AACF;AACF;;AAED,IAAA,QAAQ,CAAC,SAAD,EAAY,oBAAoB,CAAC,UAArB,GAAkC,OAAlC,GAA4C,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAAxD,CAAR;AACD,GAhED;AAiED;;AAED,SAAS,gBAAT,CAA0B,MAA1B,EAAwC;AACtC,MAAI,OAAO,MAAM,CAAC,OAAd,KAA0B,UAA9B,EAA0C;AACxC,WAAO,GAAG,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,UAAU,EAAnD;AACD;;AAED,SAAO,OAAA,CAAA,MAAA,GAAS,QAAT,CAAkB,KAAlB,CAAP;AACD;;AAED,SAAS,KAAT,CACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,QAJF,EAIoB;AAElB,MAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,IAAA,QAAQ,GAAG,OAAX;AACD;;AAED,EAAA,OAAO,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,EAArB;AACA,QAAM,oBAAoB,GAAyB;AACjD,IAAA,SAAS,EAAE,OAAO,CAAC,SAD8B;AAEjD,IAAA,EAAE,EAAE,QAF6C;AAGjD,IAAA,OAAO,EAAE,OAAO,CAAC,OAHgC;AAIjD,IAAA,UAAU,EAAE,CAAC,CAAC,OAAO,CAAC,WAAD,CAJ4B;AAKjD,IAAA,UAAU,EAAE,OAAO,OAAO,CAAC,UAAf,KAA8B,SAA9B,GAA0C,OAAO,CAAC,UAAlD,GAA+D,KAL1B;AAMjD,IAAA,mBAAmB,EAAE,OAAO,CAAC,mBANoB;AAOjD,IAAA,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,OAP8B;AASjD;AACA,IAAA,YAAY,EAAE,OAAO,OAAO,CAAC,YAAf,KAAgC,SAAhC,GAA4C,OAAO,CAAC,YAApD,GAAmE,IAVhC;AAWjD,IAAA,aAAa,EAAE,OAAO,OAAO,CAAC,aAAf,KAAiC,SAAjC,GAA6C,OAAO,CAAC,aAArD,GAAqE,IAXnC;AAYjD,IAAA,cAAc,EAAE,OAAO,OAAO,CAAC,cAAf,KAAkC,SAAlC,GAA8C,OAAO,CAAC,cAAtD,GAAuE,KAZtC;AAajD,IAAA,UAAU,EAAE,OAAO,OAAO,CAAC,UAAf,KAA8B,SAA9B,GAA0C,OAAO,CAAC,UAAlD,GAA+D,KAb1B;AAcjD,IAAA,GAAG,EAAE,OAAO,OAAO,CAAC,GAAf,KAAuB,SAAvB,GAAmC,OAAO,CAAC,GAA3C,GAAiD,KAdL;AAejD,IAAA,OAAO,EAAE;AAfwC,GAAnD;;AAkBA,MAAI,IAAI,CAAC,YAAD,CAAJ,IAAsB,IAAI,CAAC,YAAD,CAAJ,CAAmB,UAA7C,EAAyD;AACvD,IAAA,oBAAoB,CAAC,gBAArB,GAAwC,IAAI,CAAC,YAAD,CAAJ,CAAmB,UAA3D;;AAEA,QAAI,IAAI,CAAC,YAAD,CAAJ,CAAmB,oBAAvB,EAA6C;AAC3C,MAAA,oBAAoB,CAAC,oBAArB,GAA4C,IAAI,CAAC,YAAD,CAAJ,CAAmB,oBAA/D;AACD;AACF;;AAED,MAAI,OAAO,OAAO,CAAC,eAAf,KAAmC,QAAvC,EAAiD;AAC/C,IAAA,oBAAoB,CAAC,qBAArB,GAA6C,IAA7C;AACA,IAAA,IAAI,CAAC,OAAD,CAAJ,CAAc,UAAd,CAAyB,OAAO,CAAC,eAAjC;AACD,GApCiB,CAsClB;;;AACA,MAAI,IAAI,CAAC,eAAT,EAA0B;AACxB,IAAA,IAAI,CAAC,IAAL,CAAU,UAAU,CAAC,eAArB,EAAsC,IAAI,2BAAA,CAAA,mBAAJ,CAAwB,IAAxB,EAA8B,OAA9B,CAAtC;AAEA,IAAA,oBAAoB,CAAC,OAArB,GAA+B,OAAA,CAAA,GAAA,EAA/B;;AACA,IAAA,oBAAoB,CAAC,EAArB,GAA0B,CAAC,GAAD,EAAM,KAAN,KAAe;AACvC,UAAI,GAAJ,EAAS;AACP,QAAA,IAAI,CAAC,IAAL,CACE,UAAU,CAAC,cADb,EAEE,IAAI,2BAAA,CAAA,kBAAJ,CAAuB,IAAvB,EAA6B,OAA7B,EAAsC,GAAtC,EAA2C,oBAAoB,CAAC,OAAhE,CAFF;AAID,OALD,MAKO;AACL,YAAI,KAAK,KAAK,KAAK,CAAC,EAAN,KAAa,CAAb,IAAkB,KAAK,CAAC,IAA7B,CAAT,EAA6C;AAC3C,UAAA,IAAI,CAAC,IAAL,CACE,UAAU,CAAC,cADb,EAEE,IAAI,2BAAA,CAAA,kBAAJ,CAAuB,IAAvB,EAA6B,OAA7B,EAAsC,KAAtC,EAA6C,oBAAoB,CAAC,OAAlE,CAFF;AAID,SALD,MAKO;AACL,UAAA,IAAI,CAAC,IAAL,CACE,UAAU,CAAC,iBADb,EAEE,IAAI,2BAAA,CAAA,qBAAJ,CAA0B,IAA1B,EAAgC,OAAhC,EAAyC,KAAzC,EAAgD,oBAAoB,CAAC,OAArE,CAFF;AAID;AACF;;AAED,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAA,QAAQ,CAAC,GAAD,EAAM,KAAN,CAAR;AACD;AACF,KAvBD;AAwBD;;AAED,MAAI,CAAC,oBAAoB,CAAC,UAA1B,EAAsC;AACpC,IAAA,IAAI,CAAC,MAAD,CAAJ,CAAa,GAAb,CAAiB,oBAAoB,CAAC,SAAtC,EAAiD,oBAAjD;AACD;;AAED,MAAI;AACF,IAAA,IAAI,CAAC,cAAD,CAAJ,CAAqB,YAArB,CAAkC,OAAlC,EAA2C,oBAA3C;AACD,GAFD,CAEE,OAAO,CAAP,EAAU;AACV,QAAI,CAAC,oBAAoB,CAAC,UAA1B,EAAsC;AACpC,MAAA,IAAI,CAAC,MAAD,CAAJ,CAAa,MAAb,CAAoB,oBAAoB,CAAC,SAAzC;AACA,MAAA,oBAAoB,CAAC,EAArB,CAAwB,CAAxB;AACA;AACD;AACF;;AAED,MAAI,oBAAoB,CAAC,UAAzB,EAAqC;AACnC,IAAA,oBAAoB,CAAC,EAArB;AACD;AACF","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasSessionSupport = exports.CryptoConnection = exports.APM_EVENTS = exports.Connection = void 0;\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst error_1 = require(\"../error\");\nconst commands_1 = require(\"./commands\");\nconst bson_1 = require(\"../bson\");\nconst shared_1 = require(\"./wire_protocol/shared\");\nconst read_preference_1 = require(\"../read_preference\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n    constructor(stream, options) {\n        var _a, _b;\n        super();\n        this.id = options.id;\n        this.address = streamIdentifier(stream);\n        this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n        this.monitorCommands = options.monitorCommands;\n        this.serverApi = options.serverApi;\n        this.closed = false;\n        this.destroyed = false;\n        this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n        this[kGeneration] = options.generation;\n        this[kLastUseTime] = utils_1.now();\n        // setup parser stream and message handling\n        this[kQueue] = new Map();\n        this[kMessageStream] = new message_stream_1.MessageStream({\n            ...options,\n            maxBsonMessageSize: (_b = this.ismaster) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n        });\n        this[kMessageStream].on('message', messageHandler(this));\n        this[kStream] = stream;\n        stream.on('error', () => {\n            /* ignore errors, listen to `close` instead */\n        });\n        this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n        stream.on('close', () => this.handleIssue({ isClose: true }));\n        stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n        // hook the message stream up to the passed in stream\n        stream.pipe(this[kMessageStream]);\n        this[kMessageStream].pipe(stream);\n    }\n    get description() {\n        return this[kDescription];\n    }\n    get ismaster() {\n        return this[kIsMaster];\n    }\n    // the `connect` method stores the result of the handshake ismaster on the connection\n    set ismaster(response) {\n        this[kDescription].receiveResponse(response);\n        this[kDescription] = Object.freeze(this[kDescription]);\n        // TODO: remove this, and only use the `StreamDescription` in the future\n        this[kIsMaster] = response;\n    }\n    get serviceId() {\n        var _a;\n        return (_a = this.ismaster) === null || _a === void 0 ? void 0 : _a.serviceId;\n    }\n    get loadBalanced() {\n        return this.description.loadBalanced;\n    }\n    get generation() {\n        return this[kGeneration] || 0;\n    }\n    set generation(generation) {\n        this[kGeneration] = generation;\n    }\n    get idleTime() {\n        return utils_1.calculateDurationInMs(this[kLastUseTime]);\n    }\n    get clusterTime() {\n        return this[kClusterTime];\n    }\n    get stream() {\n        return this[kStream];\n    }\n    markAvailable() {\n        this[kLastUseTime] = utils_1.now();\n    }\n    handleIssue(issue) {\n        if (this.closed) {\n            return;\n        }\n        if (issue.destroy) {\n            this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n        }\n        this.closed = true;\n        for (const [, op] of this[kQueue]) {\n            if (issue.isTimeout) {\n                op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n                    beforeHandshake: this.ismaster == null\n                }));\n            }\n            else if (issue.isClose) {\n                op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n            }\n            else {\n                op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n            }\n        }\n        this[kQueue].clear();\n        this.emit(Connection.CLOSE);\n    }\n    destroy(options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = { force: false };\n        }\n        this.removeAllListeners(Connection.PINNED);\n        this.removeAllListeners(Connection.UNPINNED);\n        options = Object.assign({ force: false }, options);\n        if (this[kStream] == null || this.destroyed) {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        if (options.force) {\n            this[kStream].destroy();\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        this[kStream].end(() => {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n        });\n    }\n    /** @internal */\n    command(ns, cmd, options, callback) {\n        if (!(ns instanceof utils_1.MongoDBNamespace)) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n        }\n        const readPreference = shared_1.getReadPreference(cmd, options);\n        const shouldUseOpMsg = supportsOpMsg(this);\n        const session = options === null || options === void 0 ? void 0 : options.session;\n        let clusterTime = this.clusterTime;\n        let finalCmd = Object.assign({}, cmd);\n        if (this.serverApi) {\n            const { version, strict, deprecationErrors } = this.serverApi;\n            finalCmd.apiVersion = version;\n            if (strict != null)\n                finalCmd.apiStrict = strict;\n            if (deprecationErrors != null)\n                finalCmd.apiDeprecationErrors = deprecationErrors;\n        }\n        if (hasSessionSupport(this) && session) {\n            if (session.clusterTime &&\n                clusterTime &&\n                session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n                clusterTime = session.clusterTime;\n            }\n            const err = sessions_1.applySession(session, finalCmd, options);\n            if (err) {\n                return callback(err);\n            }\n        }\n        // if we have a known cluster time, gossip it\n        if (clusterTime) {\n            finalCmd.$clusterTime = clusterTime;\n        }\n        if (shared_1.isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n            finalCmd = {\n                $query: finalCmd,\n                $readPreference: readPreference.toJSON()\n            };\n        }\n        const commandOptions = Object.assign({\n            command: true,\n            numberToSkip: 0,\n            numberToReturn: -1,\n            checkKeys: false,\n            // This value is not overridable\n            slaveOk: readPreference.slaveOk()\n        }, options);\n        const cmdNs = `${ns.db}.$cmd`;\n        const message = shouldUseOpMsg\n            ? new commands_1.Msg(cmdNs, finalCmd, commandOptions)\n            : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n        try {\n            write(this, message, commandOptions, callback);\n        }\n        catch (err) {\n            callback(err);\n        }\n    }\n    /** @internal */\n    query(ns, cmd, options, callback) {\n        var _a;\n        const isExplain = cmd.$explain != null;\n        const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n        const batchSize = options.batchSize || 0;\n        const limit = options.limit;\n        const numberToSkip = options.skip || 0;\n        let numberToReturn = 0;\n        if (limit &&\n            (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))) {\n            numberToReturn = limit;\n        }\n        else {\n            numberToReturn = batchSize;\n        }\n        if (isExplain) {\n            // nToReturn must be 0 (match all) or negative (match N and close cursor)\n            // nToReturn > 0 will give explain results equivalent to limit(0)\n            numberToReturn = -Math.abs(limit || 0);\n        }\n        const queryOptions = {\n            numberToSkip,\n            numberToReturn,\n            pre32Limit: typeof limit === 'number' ? limit : undefined,\n            checkKeys: false,\n            slaveOk: readPreference.slaveOk()\n        };\n        if (options.projection) {\n            queryOptions.returnFieldSelector = options.projection;\n        }\n        const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n        if (typeof options.tailable === 'boolean') {\n            query.tailable = options.tailable;\n        }\n        if (typeof options.oplogReplay === 'boolean') {\n            query.oplogReplay = options.oplogReplay;\n        }\n        if (typeof options.timeout === 'boolean') {\n            query.noCursorTimeout = !options.timeout;\n        }\n        else if (typeof options.noCursorTimeout === 'boolean') {\n            query.noCursorTimeout = options.noCursorTimeout;\n        }\n        if (typeof options.awaitData === 'boolean') {\n            query.awaitData = options.awaitData;\n        }\n        if (typeof options.partial === 'boolean') {\n            query.partial = options.partial;\n        }\n        write(this, query, { [kFullResult]: true, ...bson_1.pluckBSONSerializeOptions(options) }, (err, result) => {\n            if (err || !result)\n                return callback(err, result);\n            if (isExplain && result.documents && result.documents[0]) {\n                return callback(undefined, result.documents[0]);\n            }\n            callback(undefined, result);\n        });\n    }\n    /** @internal */\n    getMore(ns, cursorId, options, callback) {\n        const fullResult = !!options[kFullResult];\n        const wireVersion = utils_1.maxWireVersion(this);\n        if (!cursorId) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n            return;\n        }\n        if (wireVersion < 4) {\n            const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n            const queryOptions = shared_1.applyCommonQueryOptions({}, Object.assign(options, { ...bson_1.pluckBSONSerializeOptions(options) }));\n            queryOptions[kFullResult] = true;\n            queryOptions.command = true;\n            write(this, getMoreOp, queryOptions, (err, response) => {\n                if (fullResult)\n                    return callback(err, response);\n                if (err)\n                    return callback(err);\n                callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n            });\n            return;\n        }\n        const getMoreCmd = {\n            getMore: cursorId,\n            collection: ns.collection\n        };\n        if (typeof options.batchSize === 'number') {\n            getMoreCmd.batchSize = Math.abs(options.batchSize);\n        }\n        if (typeof options.maxAwaitTimeMS === 'number') {\n            getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n        }\n        const commandOptions = Object.assign({\n            returnFieldSelector: null,\n            documentsReturnedIn: 'nextBatch'\n        }, options);\n        this.command(ns, getMoreCmd, commandOptions, callback);\n    }\n    /** @internal */\n    killCursors(ns, cursorIds, options, callback) {\n        if (!cursorIds || !Array.isArray(cursorIds)) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n        }\n        if (utils_1.maxWireVersion(this) < 4) {\n            try {\n                write(this, new commands_1.KillCursor(ns.toString(), cursorIds), { noResponse: true, ...options }, callback);\n            }\n            catch (err) {\n                callback(err);\n            }\n            return;\n        }\n        this.command(ns, { killCursors: ns.collection, cursors: cursorIds }, { [kFullResult]: true, ...options }, (err, response) => {\n            if (err || !response)\n                return callback(err);\n            if (response.cursorNotFound) {\n                return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n            }\n            if (!Array.isArray(response.documents) || response.documents.length === 0) {\n                return callback(\n                // TODO(NODE-3483)\n                new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n            }\n            callback(undefined, response.documents[0]);\n        });\n    }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = 'commandStarted';\n/** @event */\nConnection.COMMAND_SUCCEEDED = 'commandSucceeded';\n/** @event */\nConnection.COMMAND_FAILED = 'commandFailed';\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';\n/** @event */\nConnection.CLOSE = 'close';\n/** @event */\nConnection.MESSAGE = 'message';\n/** @event */\nConnection.PINNED = 'pinned';\n/** @event */\nConnection.UNPINNED = 'unpinned';\n/** @public */\nexports.APM_EVENTS = [\n    Connection.COMMAND_STARTED,\n    Connection.COMMAND_SUCCEEDED,\n    Connection.COMMAND_FAILED\n];\n/** @internal */\nclass CryptoConnection extends Connection {\n    constructor(stream, options) {\n        super(stream, options);\n        this[kAutoEncrypter] = options.autoEncrypter;\n    }\n    /** @internal @override */\n    command(ns, cmd, options, callback) {\n        const autoEncrypter = this[kAutoEncrypter];\n        if (!autoEncrypter) {\n            return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n        }\n        const serverWireVersion = utils_1.maxWireVersion(this);\n        if (serverWireVersion === 0) {\n            // This means the initial handshake hasn't happened yet\n            return super.command(ns, cmd, options, callback);\n        }\n        if (serverWireVersion < 8) {\n            callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n            return;\n        }\n        autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n            if (err || encrypted == null) {\n                callback(err, null);\n                return;\n            }\n            super.command(ns, encrypted, options, (err, response) => {\n                if (err || response == null) {\n                    callback(err, response);\n                    return;\n                }\n                autoEncrypter.decrypt(response, options, callback);\n            });\n        });\n    }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n    const description = conn.description;\n    return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n    const description = conn.description;\n    if (description == null) {\n        return false;\n    }\n    return utils_1.maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction messageHandler(conn) {\n    return function messageHandler(message) {\n        // always emit the message, in case we are streaming\n        conn.emit('message', message);\n        const operationDescription = conn[kQueue].get(message.responseTo);\n        if (!operationDescription) {\n            return;\n        }\n        const callback = operationDescription.cb;\n        // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n        // track response, however the server currently synthetically produces remote requests\n        // making the `responseTo` change on each response\n        conn[kQueue].delete(message.responseTo);\n        if ('moreToCome' in message && message.moreToCome) {\n            // requeue the callback for next synthetic request\n            conn[kQueue].set(message.requestId, operationDescription);\n        }\n        else if (operationDescription.socketTimeoutOverride) {\n            conn[kStream].setTimeout(conn.socketTimeoutMS);\n        }\n        try {\n            // Pass in the entire description because it has BSON parsing options\n            message.parse(operationDescription);\n        }\n        catch (err) {\n            // If this error is generated by our own code, it will already have the correct class applied\n            // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n            // in either case, it should not be wrapped\n            callback(err);\n            return;\n        }\n        if (message.documents[0]) {\n            const document = message.documents[0];\n            const session = operationDescription.session;\n            if (session) {\n                sessions_1.updateSessionFromResponse(session, document);\n            }\n            if (document.$clusterTime) {\n                conn[kClusterTime] = document.$clusterTime;\n                conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n            }\n            if (operationDescription.command) {\n                if (document.writeConcernError) {\n                    callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n                    return;\n                }\n                if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n            else {\n                // Pre 3.2 support\n                if (document.ok === 0 || document.$err || document.errmsg) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n        }\n        callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n    };\n}\nfunction streamIdentifier(stream) {\n    if (typeof stream.address === 'function') {\n        return `${stream.remoteAddress}:${stream.remotePort}`;\n    }\n    return utils_1.uuidV4().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    const operationDescription = {\n        requestId: command.requestId,\n        cb: callback,\n        session: options.session,\n        fullResult: !!options[kFullResult],\n        noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n        documentsReturnedIn: options.documentsReturnedIn,\n        command: !!options.command,\n        // for BSON parsing\n        promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n        promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n        promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n        bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n        raw: typeof options.raw === 'boolean' ? options.raw : false,\n        started: 0\n    };\n    if (conn[kDescription] && conn[kDescription].compressor) {\n        operationDescription.agreedCompressor = conn[kDescription].compressor;\n        if (conn[kDescription].zlibCompressionLevel) {\n            operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n        }\n    }\n    if (typeof options.socketTimeoutMS === 'number') {\n        operationDescription.socketTimeoutOverride = true;\n        conn[kStream].setTimeout(options.socketTimeoutMS);\n    }\n    // if command monitoring is enabled we need to modify the callback here\n    if (conn.monitorCommands) {\n        conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n        operationDescription.started = utils_1.now();\n        operationDescription.cb = (err, reply) => {\n            if (err) {\n                conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n            }\n            else {\n                if (reply && (reply.ok === 0 || reply.$err)) {\n                    conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n                }\n                else {\n                    conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n                }\n            }\n            if (typeof callback === 'function') {\n                callback(err, reply);\n            }\n        };\n    }\n    if (!operationDescription.noResponse) {\n        conn[kQueue].set(operationDescription.requestId, operationDescription);\n    }\n    try {\n        conn[kMessageStream].writeCommand(command, operationDescription);\n    }\n    catch (e) {\n        if (!operationDescription.noResponse) {\n            conn[kQueue].delete(operationDescription.requestId);\n            operationDescription.cb(e);\n            return;\n        }\n    }\n    if (operationDescription.noResponse) {\n        operationDescription.cb();\n    }\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"script"}