{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucketReadStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst error_1 = require(\"../error\");\n/**\n * A readable stream that enables you to read buffers from GridFS.\n *\n * Do not instantiate this class directly. Use `openDownloadStream()` instead.\n * @public\n */\n\n\nclass GridFSBucketReadStream extends stream_1.Readable {\n  /** @internal\n   * @param chunks - Handle for chunks collection\n   * @param files - Handle for files collection\n   * @param readPreference - The read preference to use\n   * @param filter - The filter to use to find the file document\n   */\n  constructor(chunks, files, readPreference, filter, options) {\n    super();\n    this.s = {\n      bytesToTrim: 0,\n      bytesToSkip: 0,\n      bytesRead: 0,\n      chunks,\n      expected: 0,\n      files,\n      filter,\n      init: false,\n      expectedEnd: 0,\n      options: {\n        start: 0,\n        end: 0,\n        ...options\n      },\n      readPreference\n    };\n  }\n  /**\n   * Reads from the cursor and pushes to the stream.\n   * Private Impl, do not call directly\n   * @internal\n   */\n\n\n  _read() {\n    if (this.destroyed) return;\n    waitForFile(this, () => doRead(this));\n  }\n  /**\n   * Sets the 0-based offset in bytes to start streaming from. Throws\n   * an error if this stream has entered flowing mode\n   * (e.g. if you've already called `on('data')`)\n   *\n   * @param start - 0-based offset in bytes to start streaming from\n   */\n\n\n  start(start = 0) {\n    throwIfInitialized(this);\n    this.s.options.start = start;\n    return this;\n  }\n  /**\n   * Sets the 0-based offset in bytes to start streaming from. Throws\n   * an error if this stream has entered flowing mode\n   * (e.g. if you've already called `on('data')`)\n   *\n   * @param end - Offset in bytes to stop reading at\n   */\n\n\n  end(end = 0) {\n    throwIfInitialized(this);\n    this.s.options.end = end;\n    return this;\n  }\n  /**\n   * Marks this stream as aborted (will never push another `data` event)\n   * and kills the underlying cursor. Will emit the 'end' event, and then\n   * the 'close' event once the cursor is successfully killed.\n   *\n   * @param callback - called when the cursor is successfully closed or an error occurred.\n   */\n\n\n  abort(callback) {\n    this.push(null);\n    this.destroyed = true;\n\n    if (this.s.cursor) {\n      this.s.cursor.close(error => {\n        this.emit(GridFSBucketReadStream.CLOSE);\n        callback && callback(error);\n      });\n    } else {\n      if (!this.s.init) {\n        // If not initialized, fire close event because we will never\n        // get a cursor\n        this.emit(GridFSBucketReadStream.CLOSE);\n      }\n\n      callback && callback();\n    }\n  }\n\n}\n\nexports.GridFSBucketReadStream = GridFSBucketReadStream;\n/**\n * An error occurred\n * @event\n */\n\nGridFSBucketReadStream.ERROR = 'error';\n/**\n * Fires when the stream loaded the file document corresponding to the provided id.\n * @event\n */\n\nGridFSBucketReadStream.FILE = 'file';\n/**\n * Emitted when a chunk of data is available to be consumed.\n * @event\n */\n\nGridFSBucketReadStream.DATA = 'data';\n/**\n * Fired when the stream is exhausted (no more data events).\n * @event\n */\n\nGridFSBucketReadStream.END = 'end';\n/**\n * Fired when the stream is exhausted and the underlying cursor is killed\n * @event\n */\n\nGridFSBucketReadStream.CLOSE = 'close';\n\nfunction throwIfInitialized(stream) {\n  if (stream.s.init) {\n    throw new error_1.MongoGridFSStreamError('Options cannot be changed after the stream is initialized');\n  }\n}\n\nfunction doRead(stream) {\n  if (stream.destroyed) return;\n  if (!stream.s.cursor) return;\n  if (!stream.s.file) return;\n  stream.s.cursor.next((error, doc) => {\n    if (stream.destroyed) {\n      return;\n    }\n\n    if (error) {\n      stream.emit(GridFSBucketReadStream.ERROR, error);\n      return;\n    }\n\n    if (!doc) {\n      stream.push(null);\n      process.nextTick(() => {\n        if (!stream.s.cursor) return;\n        stream.s.cursor.close(error => {\n          if (error) {\n            stream.emit(GridFSBucketReadStream.ERROR, error);\n            return;\n          }\n\n          stream.emit(GridFSBucketReadStream.CLOSE);\n        });\n      });\n      return;\n    }\n\n    if (!stream.s.file) return;\n    const bytesRemaining = stream.s.file.length - stream.s.bytesRead;\n    const expectedN = stream.s.expected++;\n    const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);\n\n    if (doc.n > expectedN) {\n      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));\n    }\n\n    if (doc.n < expectedN) {\n      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));\n    }\n\n    let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;\n\n    if (buf.byteLength !== expectedLength) {\n      if (bytesRemaining <= 0) {\n        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}`));\n      }\n\n      return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));\n    }\n\n    stream.s.bytesRead += buf.byteLength;\n\n    if (buf.byteLength === 0) {\n      return stream.push(null);\n    }\n\n    let sliceStart = null;\n    let sliceEnd = null;\n\n    if (stream.s.bytesToSkip != null) {\n      sliceStart = stream.s.bytesToSkip;\n      stream.s.bytesToSkip = 0;\n    }\n\n    const atEndOfStream = expectedN === stream.s.expectedEnd - 1;\n    const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;\n\n    if (atEndOfStream && stream.s.bytesToTrim != null) {\n      sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;\n    } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {\n      sliceEnd = bytesLeftToRead;\n    }\n\n    if (sliceStart != null || sliceEnd != null) {\n      buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);\n    }\n\n    stream.push(buf);\n  });\n}\n\nfunction init(stream) {\n  const findOneOptions = {};\n\n  if (stream.s.readPreference) {\n    findOneOptions.readPreference = stream.s.readPreference;\n  }\n\n  if (stream.s.options && stream.s.options.sort) {\n    findOneOptions.sort = stream.s.options.sort;\n  }\n\n  if (stream.s.options && stream.s.options.skip) {\n    findOneOptions.skip = stream.s.options.skip;\n  }\n\n  stream.s.files.findOne(stream.s.filter, findOneOptions, (error, doc) => {\n    if (error) {\n      return stream.emit(GridFSBucketReadStream.ERROR, error);\n    }\n\n    if (!doc) {\n      const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;\n      const errmsg = `FileNotFound: file ${identifier} was not found`; // TODO(NODE-3483)\n\n      const err = new error_1.MongoRuntimeError(errmsg);\n      err.code = 'ENOENT'; // TODO: NODE-3338 set property as part of constructor\n\n      return stream.emit(GridFSBucketReadStream.ERROR, err);\n    } // If document is empty, kill the stream immediately and don't\n    // execute any reads\n\n\n    if (doc.length <= 0) {\n      stream.push(null);\n      return;\n    }\n\n    if (stream.destroyed) {\n      // If user destroys the stream before we have a cursor, wait\n      // until the query is done to say we're 'closed' because we can't\n      // cancel a query.\n      stream.emit(GridFSBucketReadStream.CLOSE);\n      return;\n    }\n\n    try {\n      stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);\n    } catch (error) {\n      return stream.emit(GridFSBucketReadStream.ERROR, error);\n    }\n\n    const filter = {\n      files_id: doc._id\n    }; // Currently (MongoDB 3.4.4) skip function does not support the index,\n    // it needs to retrieve all the documents first and then skip them. (CS-25811)\n    // As work around we use $gte on the \"n\" field.\n\n    if (stream.s.options && stream.s.options.start != null) {\n      const skip = Math.floor(stream.s.options.start / doc.chunkSize);\n\n      if (skip > 0) {\n        filter['n'] = {\n          $gte: skip\n        };\n      }\n    }\n\n    stream.s.cursor = stream.s.chunks.find(filter).sort({\n      n: 1\n    });\n\n    if (stream.s.readPreference) {\n      stream.s.cursor.withReadPreference(stream.s.readPreference);\n    }\n\n    stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);\n    stream.s.file = doc;\n\n    try {\n      stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);\n    } catch (error) {\n      return stream.emit(GridFSBucketReadStream.ERROR, error);\n    }\n\n    stream.emit(GridFSBucketReadStream.FILE, doc);\n  });\n}\n\nfunction waitForFile(stream, callback) {\n  if (stream.s.file) {\n    return callback();\n  }\n\n  if (!stream.s.init) {\n    init(stream);\n    stream.s.init = true;\n  }\n\n  stream.once('file', () => {\n    callback();\n  });\n}\n\nfunction handleStartOption(stream, doc, options) {\n  if (options && options.start != null) {\n    if (options.start > doc.length) {\n      throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);\n    }\n\n    if (options.start < 0) {\n      throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);\n    }\n\n    if (options.end != null && options.end < options.start) {\n      throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);\n    }\n\n    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;\n    stream.s.expected = Math.floor(options.start / doc.chunkSize);\n    return options.start - stream.s.bytesRead;\n  }\n\n  throw new error_1.MongoInvalidArgumentError('Start option must be defined');\n}\n\nfunction handleEndOption(stream, doc, cursor, options) {\n  if (options && options.end != null) {\n    if (options.end > doc.length) {\n      throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);\n    }\n\n    if (options.start == null || options.start < 0) {\n      throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);\n    }\n\n    const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;\n    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);\n    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);\n    return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;\n  }\n\n  throw new error_1.MongoInvalidArgumentError('End option must be defined');\n}","map":{"version":3,"sources":["../../src/gridfs/download.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucketReadStream = void 0;\nconst stream_1 = require(\"stream\");\nconst error_1 = require(\"../error\");\n/**\n * A readable stream that enables you to read buffers from GridFS.\n *\n * Do not instantiate this class directly. Use `openDownloadStream()` instead.\n * @public\n */\nclass GridFSBucketReadStream extends stream_1.Readable {\n    /** @internal\n     * @param chunks - Handle for chunks collection\n     * @param files - Handle for files collection\n     * @param readPreference - The read preference to use\n     * @param filter - The filter to use to find the file document\n     */\n    constructor(chunks, files, readPreference, filter, options) {\n        super();\n        this.s = {\n            bytesToTrim: 0,\n            bytesToSkip: 0,\n            bytesRead: 0,\n            chunks,\n            expected: 0,\n            files,\n            filter,\n            init: false,\n            expectedEnd: 0,\n            options: {\n                start: 0,\n                end: 0,\n                ...options\n            },\n            readPreference\n        };\n    }\n    /**\n     * Reads from the cursor and pushes to the stream.\n     * Private Impl, do not call directly\n     * @internal\n     */\n    _read() {\n        if (this.destroyed)\n            return;\n        waitForFile(this, () => doRead(this));\n    }\n    /**\n     * Sets the 0-based offset in bytes to start streaming from. Throws\n     * an error if this stream has entered flowing mode\n     * (e.g. if you've already called `on('data')`)\n     *\n     * @param start - 0-based offset in bytes to start streaming from\n     */\n    start(start = 0) {\n        throwIfInitialized(this);\n        this.s.options.start = start;\n        return this;\n    }\n    /**\n     * Sets the 0-based offset in bytes to start streaming from. Throws\n     * an error if this stream has entered flowing mode\n     * (e.g. if you've already called `on('data')`)\n     *\n     * @param end - Offset in bytes to stop reading at\n     */\n    end(end = 0) {\n        throwIfInitialized(this);\n        this.s.options.end = end;\n        return this;\n    }\n    /**\n     * Marks this stream as aborted (will never push another `data` event)\n     * and kills the underlying cursor. Will emit the 'end' event, and then\n     * the 'close' event once the cursor is successfully killed.\n     *\n     * @param callback - called when the cursor is successfully closed or an error occurred.\n     */\n    abort(callback) {\n        this.push(null);\n        this.destroyed = true;\n        if (this.s.cursor) {\n            this.s.cursor.close(error => {\n                this.emit(GridFSBucketReadStream.CLOSE);\n                callback && callback(error);\n            });\n        }\n        else {\n            if (!this.s.init) {\n                // If not initialized, fire close event because we will never\n                // get a cursor\n                this.emit(GridFSBucketReadStream.CLOSE);\n            }\n            callback && callback();\n        }\n    }\n}\nexports.GridFSBucketReadStream = GridFSBucketReadStream;\n/**\n * An error occurred\n * @event\n */\nGridFSBucketReadStream.ERROR = 'error';\n/**\n * Fires when the stream loaded the file document corresponding to the provided id.\n * @event\n */\nGridFSBucketReadStream.FILE = 'file';\n/**\n * Emitted when a chunk of data is available to be consumed.\n * @event\n */\nGridFSBucketReadStream.DATA = 'data';\n/**\n * Fired when the stream is exhausted (no more data events).\n * @event\n */\nGridFSBucketReadStream.END = 'end';\n/**\n * Fired when the stream is exhausted and the underlying cursor is killed\n * @event\n */\nGridFSBucketReadStream.CLOSE = 'close';\nfunction throwIfInitialized(stream) {\n    if (stream.s.init) {\n        throw new error_1.MongoGridFSStreamError('Options cannot be changed after the stream is initialized');\n    }\n}\nfunction doRead(stream) {\n    if (stream.destroyed)\n        return;\n    if (!stream.s.cursor)\n        return;\n    if (!stream.s.file)\n        return;\n    stream.s.cursor.next((error, doc) => {\n        if (stream.destroyed) {\n            return;\n        }\n        if (error) {\n            stream.emit(GridFSBucketReadStream.ERROR, error);\n            return;\n        }\n        if (!doc) {\n            stream.push(null);\n            process.nextTick(() => {\n                if (!stream.s.cursor)\n                    return;\n                stream.s.cursor.close(error => {\n                    if (error) {\n                        stream.emit(GridFSBucketReadStream.ERROR, error);\n                        return;\n                    }\n                    stream.emit(GridFSBucketReadStream.CLOSE);\n                });\n            });\n            return;\n        }\n        if (!stream.s.file)\n            return;\n        const bytesRemaining = stream.s.file.length - stream.s.bytesRead;\n        const expectedN = stream.s.expected++;\n        const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);\n        if (doc.n > expectedN) {\n            return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));\n        }\n        if (doc.n < expectedN) {\n            return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));\n        }\n        let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;\n        if (buf.byteLength !== expectedLength) {\n            if (bytesRemaining <= 0) {\n                return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}`));\n            }\n            return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));\n        }\n        stream.s.bytesRead += buf.byteLength;\n        if (buf.byteLength === 0) {\n            return stream.push(null);\n        }\n        let sliceStart = null;\n        let sliceEnd = null;\n        if (stream.s.bytesToSkip != null) {\n            sliceStart = stream.s.bytesToSkip;\n            stream.s.bytesToSkip = 0;\n        }\n        const atEndOfStream = expectedN === stream.s.expectedEnd - 1;\n        const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;\n        if (atEndOfStream && stream.s.bytesToTrim != null) {\n            sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;\n        }\n        else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {\n            sliceEnd = bytesLeftToRead;\n        }\n        if (sliceStart != null || sliceEnd != null) {\n            buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);\n        }\n        stream.push(buf);\n    });\n}\nfunction init(stream) {\n    const findOneOptions = {};\n    if (stream.s.readPreference) {\n        findOneOptions.readPreference = stream.s.readPreference;\n    }\n    if (stream.s.options && stream.s.options.sort) {\n        findOneOptions.sort = stream.s.options.sort;\n    }\n    if (stream.s.options && stream.s.options.skip) {\n        findOneOptions.skip = stream.s.options.skip;\n    }\n    stream.s.files.findOne(stream.s.filter, findOneOptions, (error, doc) => {\n        if (error) {\n            return stream.emit(GridFSBucketReadStream.ERROR, error);\n        }\n        if (!doc) {\n            const identifier = stream.s.filter._id\n                ? stream.s.filter._id.toString()\n                : stream.s.filter.filename;\n            const errmsg = `FileNotFound: file ${identifier} was not found`;\n            // TODO(NODE-3483)\n            const err = new error_1.MongoRuntimeError(errmsg);\n            err.code = 'ENOENT'; // TODO: NODE-3338 set property as part of constructor\n            return stream.emit(GridFSBucketReadStream.ERROR, err);\n        }\n        // If document is empty, kill the stream immediately and don't\n        // execute any reads\n        if (doc.length <= 0) {\n            stream.push(null);\n            return;\n        }\n        if (stream.destroyed) {\n            // If user destroys the stream before we have a cursor, wait\n            // until the query is done to say we're 'closed' because we can't\n            // cancel a query.\n            stream.emit(GridFSBucketReadStream.CLOSE);\n            return;\n        }\n        try {\n            stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);\n        }\n        catch (error) {\n            return stream.emit(GridFSBucketReadStream.ERROR, error);\n        }\n        const filter = { files_id: doc._id };\n        // Currently (MongoDB 3.4.4) skip function does not support the index,\n        // it needs to retrieve all the documents first and then skip them. (CS-25811)\n        // As work around we use $gte on the \"n\" field.\n        if (stream.s.options && stream.s.options.start != null) {\n            const skip = Math.floor(stream.s.options.start / doc.chunkSize);\n            if (skip > 0) {\n                filter['n'] = { $gte: skip };\n            }\n        }\n        stream.s.cursor = stream.s.chunks.find(filter).sort({ n: 1 });\n        if (stream.s.readPreference) {\n            stream.s.cursor.withReadPreference(stream.s.readPreference);\n        }\n        stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);\n        stream.s.file = doc;\n        try {\n            stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);\n        }\n        catch (error) {\n            return stream.emit(GridFSBucketReadStream.ERROR, error);\n        }\n        stream.emit(GridFSBucketReadStream.FILE, doc);\n    });\n}\nfunction waitForFile(stream, callback) {\n    if (stream.s.file) {\n        return callback();\n    }\n    if (!stream.s.init) {\n        init(stream);\n        stream.s.init = true;\n    }\n    stream.once('file', () => {\n        callback();\n    });\n}\nfunction handleStartOption(stream, doc, options) {\n    if (options && options.start != null) {\n        if (options.start > doc.length) {\n            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);\n        }\n        if (options.start < 0) {\n            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);\n        }\n        if (options.end != null && options.end < options.start) {\n            throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);\n        }\n        stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;\n        stream.s.expected = Math.floor(options.start / doc.chunkSize);\n        return options.start - stream.s.bytesRead;\n    }\n    throw new error_1.MongoInvalidArgumentError('Start option must be defined');\n}\nfunction handleEndOption(stream, doc, cursor, options) {\n    if (options && options.end != null) {\n        if (options.end > doc.length) {\n            throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);\n        }\n        if (options.start == null || options.start < 0) {\n            throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);\n        }\n        const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;\n        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);\n        stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);\n        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;\n    }\n    throw new error_1.MongoInvalidArgumentError('End option must be defined');\n}\n//# sourceMappingURL=download.js.map"]},"metadata":{},"sourceType":"script"}