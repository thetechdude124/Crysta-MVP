{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst utils_1 = require(\"../utils\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst command_1 = require(\"./command\");\n\nconst error_1 = require(\"../error\");\n\nconst operation_1 = require(\"./operation\");\n\nconst db_1 = require(\"../db\");\n\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\n\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    } // Add any other options passed in\n\n\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n\n    options = Object.assign({}, options); // If we have a read preference and inline is not set as output fail hard\n\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary; // Decorate command with writeConcern if supported\n\n      utils_1.applyWriteConcern(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      utils_1.decorateWithReadConcern(mapCommandHash, coll, options);\n    } // Is bypassDocumentValidation specified\n\n\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // Have we specified collation\n\n\n    try {\n      utils_1.decorateWithCollation(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (this.explain && utils_1.maxWireVersion(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    } // Execute command\n\n\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err); // Check if we have an error\n\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      } // If an explain option was executed, don't process the server results\n\n\n      if (this.explain) return callback(undefined, result); // Create statistics value\n\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      } // The returned collection\n\n\n      let collection = null; // If we have an object it's a different db\n\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result; // Return a collection from another db\n\n        collection = new db_1.Db(coll.s.db.s.client, doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      } // If we wish for no verbosity\n\n\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      } // Return stats as third set of values\n\n\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n\n}\n\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\n\nfunction processScope(scope) {\n  if (!utils_1.isObject(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const newScope = {};\n\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n\n  return newScope;\n}\n\noperation_1.defineAspects(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"sources":["../../src/operations/map_reduce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapReduceOperation = void 0;\nconst bson_1 = require(\"../bson\");\nconst utils_1 = require(\"../utils\");\nconst read_preference_1 = require(\"../read_preference\");\nconst command_1 = require(\"./command\");\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nconst db_1 = require(\"../db\");\nconst exclusionList = [\n    'explain',\n    'readPreference',\n    'readConcern',\n    'session',\n    'bypassDocumentValidation',\n    'writeConcern',\n    'raw',\n    'fieldsAsRaw',\n    'promoteLongs',\n    'promoteValues',\n    'promoteBuffers',\n    'bsonRegExp',\n    'serializeFunctions',\n    'ignoreUndefined',\n    'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nclass MapReduceOperation extends command_1.CommandOperation {\n    /**\n     * Constructs a MapReduce operation.\n     *\n     * @param collection - Collection instance.\n     * @param map - The mapping function.\n     * @param reduce - The reduce function.\n     * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n     */\n    constructor(collection, map, reduce, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collection = collection;\n        this.map = map;\n        this.reduce = reduce;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const map = this.map;\n        const reduce = this.reduce;\n        let options = this.options;\n        const mapCommandHash = {\n            mapReduce: coll.collectionName,\n            map: map,\n            reduce: reduce\n        };\n        if (options.scope) {\n            mapCommandHash.scope = processScope(options.scope);\n        }\n        // Add any other options passed in\n        for (const n in options) {\n            // Only include if not in exclusion list\n            if (exclusionList.indexOf(n) === -1) {\n                mapCommandHash[n] = options[n];\n            }\n        }\n        options = Object.assign({}, options);\n        // If we have a read preference and inline is not set as output fail hard\n        if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary &&\n            options.out &&\n            options.out.inline !== 1 &&\n            options.out !== 'inline') {\n            // Force readPreference to primary\n            options.readPreference = read_preference_1.ReadPreference.primary;\n            // Decorate command with writeConcern if supported\n            utils_1.applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);\n        }\n        else {\n            utils_1.decorateWithReadConcern(mapCommandHash, coll, options);\n        }\n        // Is bypassDocumentValidation specified\n        if (options.bypassDocumentValidation === true) {\n            mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n        }\n        // Have we specified collation\n        try {\n            utils_1.decorateWithCollation(mapCommandHash, coll, options);\n        }\n        catch (err) {\n            return callback(err);\n        }\n        if (this.explain && utils_1.maxWireVersion(server) < 9) {\n            callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n            return;\n        }\n        // Execute command\n        super.executeCommand(server, session, mapCommandHash, (err, result) => {\n            if (err)\n                return callback(err);\n            // Check if we have an error\n            if (1 !== result.ok || result.err || result.errmsg) {\n                return callback(new error_1.MongoServerError(result));\n            }\n            // If an explain option was executed, don't process the server results\n            if (this.explain)\n                return callback(undefined, result);\n            // Create statistics value\n            const stats = {};\n            if (result.timeMillis)\n                stats['processtime'] = result.timeMillis;\n            if (result.counts)\n                stats['counts'] = result.counts;\n            if (result.timing)\n                stats['timing'] = result.timing;\n            // invoked with inline?\n            if (result.results) {\n                // If we wish for no verbosity\n                if (options['verbose'] == null || !options['verbose']) {\n                    return callback(undefined, result.results);\n                }\n                return callback(undefined, { results: result.results, stats: stats });\n            }\n            // The returned collection\n            let collection = null;\n            // If we have an object it's a different db\n            if (result.result != null && typeof result.result === 'object') {\n                const doc = result.result;\n                // Return a collection from another db\n                collection = new db_1.Db(coll.s.db.s.client, doc.db, coll.s.db.s.options).collection(doc.collection);\n            }\n            else {\n                // Create a collection object that wraps the result collection\n                collection = coll.s.db.collection(result.result);\n            }\n            // If we wish for no verbosity\n            if (options['verbose'] == null || !options['verbose']) {\n                return callback(err, collection);\n            }\n            // Return stats as third set of values\n            callback(err, { collection, stats });\n        });\n    }\n}\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n    if (!utils_1.isObject(scope) || scope._bsontype === 'ObjectID') {\n        return scope;\n    }\n    const newScope = {};\n    for (const key of Object.keys(scope)) {\n        if ('function' === typeof scope[key]) {\n            newScope[key] = new bson_1.Code(String(scope[key]));\n        }\n        else if (scope[key]._bsontype === 'Code') {\n            newScope[key] = scope[key];\n        }\n        else {\n            newScope[key] = processScope(scope[key]);\n        }\n    }\n    return newScope;\n}\noperation_1.defineAspects(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);\n//# sourceMappingURL=map_reduce.js.map"]},"metadata":{},"sourceType":"script"}