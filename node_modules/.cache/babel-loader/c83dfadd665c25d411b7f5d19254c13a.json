{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucketWriteStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst write_concern_1 = require(\"./../write_concern\");\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n * @public\n */\n\n\nclass GridFSBucketWriteStream extends stream_1.Writable {\n  /** @internal\n   * @param bucket - Handle for this stream's corresponding bucket\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n  constructor(bucket, filename, options) {\n    super();\n    options = options !== null && options !== void 0 ? options : {};\n    this.bucket = bucket;\n    this.chunks = bucket.s._chunksCollection;\n    this.filename = filename;\n    this.files = bucket.s._filesCollection;\n    this.options = options;\n    this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern; // Signals the write is all done\n\n    this.done = false;\n    this.id = options.id ? options.id : new bson_1.ObjectId(); // properly inherit the default chunksize from parent\n\n    this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;\n    this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n    this.length = 0;\n    this.n = 0;\n    this.pos = 0;\n    this.state = {\n      streamEnd: false,\n      outstandingRequests: 0,\n      errored: false,\n      aborted: false\n    };\n\n    if (!this.bucket.s.calledOpenUploadStream) {\n      this.bucket.s.calledOpenUploadStream = true;\n      checkIndexes(this, () => {\n        this.bucket.s.checkedIndexes = true;\n        this.bucket.emit('index');\n      });\n    }\n  }\n\n  write(chunk, encodingOrCallback, callback) {\n    const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n    callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n    return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback));\n  }\n\n  abort(callback) {\n    return utils_1.maybePromise(callback, callback => {\n      if (this.state.streamEnd) {\n        // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n        return callback(new error_1.MongoAPIError('Cannot abort a stream that has already completed'));\n      }\n\n      if (this.state.aborted) {\n        // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n        return callback(new error_1.MongoAPIError('Cannot call abort() on a stream twice'));\n      }\n\n      this.state.aborted = true;\n      this.chunks.deleteMany({\n        files_id: this.id\n      }, error => callback(error));\n    });\n  }\n\n  end(chunkOrCallback, encodingOrCallback, callback) {\n    const chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;\n    const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n    callback = typeof chunkOrCallback === 'function' ? chunkOrCallback : typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n    if (checkAborted(this, callback)) return;\n    this.state.streamEnd = true;\n\n    if (callback) {\n      this.once(GridFSBucketWriteStream.FINISH, result => {\n        if (callback) callback(undefined, result);\n      });\n    }\n\n    if (!chunk) {\n      waitForIndexes(this, () => !!writeRemnant(this));\n      return;\n    }\n\n    this.write(chunk, encoding, () => {\n      writeRemnant(this);\n    });\n  }\n\n}\n\nexports.GridFSBucketWriteStream = GridFSBucketWriteStream;\n/** @event */\n\nGridFSBucketWriteStream.CLOSE = 'close';\n/** @event */\n\nGridFSBucketWriteStream.ERROR = 'error';\n/**\n * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.\n * @event\n */\n\nGridFSBucketWriteStream.FINISH = 'finish';\n\nfunction __handleError(stream, error, callback) {\n  if (stream.state.errored) {\n    return;\n  }\n\n  stream.state.errored = true;\n\n  if (callback) {\n    return callback(error);\n  }\n\n  stream.emit(GridFSBucketWriteStream.ERROR, error);\n}\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: new bson_1.ObjectId(),\n    files_id: filesId,\n    n,\n    data\n  };\n}\n\nfunction checkChunksIndex(stream, callback) {\n  stream.chunks.listIndexes().toArray((error, indexes) => {\n    let index;\n\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        index = {\n          files_id: 1,\n          n: 1\n        };\n        stream.chunks.createIndex(index, {\n          background: false,\n          unique: true\n        }, error => {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n        return;\n      }\n\n      return callback(error);\n    }\n\n    let hasChunksIndex = false;\n\n    if (indexes) {\n      indexes.forEach(index => {\n        if (index.key) {\n          const keys = Object.keys(index.key);\n\n          if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n            hasChunksIndex = true;\n          }\n        }\n      });\n    }\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = {\n        files_id: 1,\n        n: 1\n      };\n      const writeConcernOptions = getWriteOptions(stream);\n      stream.chunks.createIndex(index, { ...writeConcernOptions,\n        background: true,\n        unique: true\n      }, callback);\n    }\n  });\n}\n\nfunction checkDone(stream, callback) {\n  if (stream.done) return true;\n\n  if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {\n    // Set done so we do not trigger duplicate createFilesDoc\n    stream.done = true; // Create a new files doc\n\n    const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);\n\n    if (checkAborted(stream, callback)) {\n      return false;\n    }\n\n    stream.files.insertOne(filesDoc, getWriteOptions(stream), error => {\n      if (error) {\n        return __handleError(stream, error, callback);\n      }\n\n      stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);\n      stream.emit(GridFSBucketWriteStream.CLOSE);\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkIndexes(stream, callback) {\n  stream.files.findOne({}, {\n    projection: {\n      _id: 1\n    }\n  }, (error, doc) => {\n    if (error) {\n      return callback(error);\n    }\n\n    if (doc) {\n      return callback();\n    }\n\n    stream.files.listIndexes().toArray((error, indexes) => {\n      let index;\n\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n          index = {\n            filename: 1,\n            uploadDate: 1\n          };\n          stream.files.createIndex(index, {\n            background: false\n          }, error => {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(stream, callback);\n          });\n          return;\n        }\n\n        return callback(error);\n      }\n\n      let hasFileIndex = false;\n\n      if (indexes) {\n        indexes.forEach(index => {\n          const keys = Object.keys(index.key);\n\n          if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n            hasFileIndex = true;\n          }\n        });\n      }\n\n      if (hasFileIndex) {\n        checkChunksIndex(stream, callback);\n      } else {\n        index = {\n          filename: 1,\n          uploadDate: 1\n        };\n        const writeConcernOptions = getWriteOptions(stream);\n        stream.files.createIndex(index, { ...writeConcernOptions,\n          background: false\n        }, error => {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(stream, callback);\n        });\n      }\n    });\n  });\n}\n\nfunction createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {\n  const ret = {\n    _id,\n    length,\n    chunkSize,\n    uploadDate: new Date(),\n    filename\n  };\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, chunk, encoding, callback) {\n  if (checkAborted(stream, callback)) {\n    return false;\n  }\n\n  const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n  stream.length += inputBuf.length; // Input is small enough to fit in our buffer\n\n  if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {\n    inputBuf.copy(stream.bufToStore, stream.pos);\n    stream.pos += inputBuf.length;\n    callback && callback(); // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n\n    return true;\n  } // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n\n\n  let inputBufRemaining = inputBuf.length;\n  let spaceRemaining = stream.chunkSizeBytes - stream.pos;\n  let numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  let outstandingRequests = 0;\n\n  while (inputBufRemaining > 0) {\n    const inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);\n    stream.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n    let doc;\n\n    if (spaceRemaining === 0) {\n      doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));\n      ++stream.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(stream, callback)) {\n        return false;\n      }\n\n      stream.chunks.insertOne(doc, getWriteOptions(stream), error => {\n        if (error) {\n          return __handleError(stream, error);\n        }\n\n        --stream.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          stream.emit('drain', doc);\n          callback && callback();\n          checkDone(stream);\n        }\n      });\n      spaceRemaining = stream.chunkSizeBytes;\n      stream.pos = 0;\n      ++stream.n;\n    }\n\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  } // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n\n\n  return false;\n}\n\nfunction getWriteOptions(stream) {\n  const obj = {};\n\n  if (stream.writeConcern) {\n    obj.writeConcern = {\n      w: stream.writeConcern.w,\n      wtimeout: stream.writeConcern.wtimeout,\n      j: stream.writeConcern.j\n    };\n  }\n\n  return obj;\n}\n\nfunction waitForIndexes(stream, callback) {\n  if (stream.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  stream.bucket.once('index', () => {\n    callback(true);\n  });\n  return true;\n}\n\nfunction writeRemnant(stream, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (stream.pos === 0) {\n    return checkDone(stream, callback);\n  }\n\n  ++stream.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n\n  const remnant = Buffer.alloc(stream.pos);\n  stream.bufToStore.copy(remnant, 0, 0, stream.pos);\n  const doc = createChunkDoc(stream.id, stream.n, remnant); // If the stream was aborted, do not write remnant\n\n  if (checkAborted(stream, callback)) {\n    return false;\n  }\n\n  stream.chunks.insertOne(doc, getWriteOptions(stream), error => {\n    if (error) {\n      return __handleError(stream, error);\n    }\n\n    --stream.state.outstandingRequests;\n    checkDone(stream);\n  });\n  return true;\n}\n\nfunction checkAborted(stream, callback) {\n  if (stream.state.aborted) {\n    if (typeof callback === 'function') {\n      // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError\n      callback(new error_1.MongoAPIError('Stream has been aborted'));\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../src/gridfs/upload.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucketWriteStream = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"./../write_concern\");\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n * @public\n */\nclass GridFSBucketWriteStream extends stream_1.Writable {\n    /** @internal\n     * @param bucket - Handle for this stream's corresponding bucket\n     * @param filename - The value of the 'filename' key in the files doc\n     * @param options - Optional settings.\n     */\n    constructor(bucket, filename, options) {\n        super();\n        options = options !== null && options !== void 0 ? options : {};\n        this.bucket = bucket;\n        this.chunks = bucket.s._chunksCollection;\n        this.filename = filename;\n        this.files = bucket.s._filesCollection;\n        this.options = options;\n        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;\n        // Signals the write is all done\n        this.done = false;\n        this.id = options.id ? options.id : new bson_1.ObjectId();\n        // properly inherit the default chunksize from parent\n        this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;\n        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n        this.length = 0;\n        this.n = 0;\n        this.pos = 0;\n        this.state = {\n            streamEnd: false,\n            outstandingRequests: 0,\n            errored: false,\n            aborted: false\n        };\n        if (!this.bucket.s.calledOpenUploadStream) {\n            this.bucket.s.calledOpenUploadStream = true;\n            checkIndexes(this, () => {\n                this.bucket.s.checkedIndexes = true;\n                this.bucket.emit('index');\n            });\n        }\n    }\n    write(chunk, encodingOrCallback, callback) {\n        const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n        callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n        return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback));\n    }\n    abort(callback) {\n        return utils_1.maybePromise(callback, callback => {\n            if (this.state.streamEnd) {\n                // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n                return callback(new error_1.MongoAPIError('Cannot abort a stream that has already completed'));\n            }\n            if (this.state.aborted) {\n                // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n                return callback(new error_1.MongoAPIError('Cannot call abort() on a stream twice'));\n            }\n            this.state.aborted = true;\n            this.chunks.deleteMany({ files_id: this.id }, error => callback(error));\n        });\n    }\n    end(chunkOrCallback, encodingOrCallback, callback) {\n        const chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;\n        const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n        callback =\n            typeof chunkOrCallback === 'function'\n                ? chunkOrCallback\n                : typeof encodingOrCallback === 'function'\n                    ? encodingOrCallback\n                    : callback;\n        if (checkAborted(this, callback))\n            return;\n        this.state.streamEnd = true;\n        if (callback) {\n            this.once(GridFSBucketWriteStream.FINISH, (result) => {\n                if (callback)\n                    callback(undefined, result);\n            });\n        }\n        if (!chunk) {\n            waitForIndexes(this, () => !!writeRemnant(this));\n            return;\n        }\n        this.write(chunk, encoding, () => {\n            writeRemnant(this);\n        });\n    }\n}\nexports.GridFSBucketWriteStream = GridFSBucketWriteStream;\n/** @event */\nGridFSBucketWriteStream.CLOSE = 'close';\n/** @event */\nGridFSBucketWriteStream.ERROR = 'error';\n/**\n * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.\n * @event\n */\nGridFSBucketWriteStream.FINISH = 'finish';\nfunction __handleError(stream, error, callback) {\n    if (stream.state.errored) {\n        return;\n    }\n    stream.state.errored = true;\n    if (callback) {\n        return callback(error);\n    }\n    stream.emit(GridFSBucketWriteStream.ERROR, error);\n}\nfunction createChunkDoc(filesId, n, data) {\n    return {\n        _id: new bson_1.ObjectId(),\n        files_id: filesId,\n        n,\n        data\n    };\n}\nfunction checkChunksIndex(stream, callback) {\n    stream.chunks.listIndexes().toArray((error, indexes) => {\n        let index;\n        if (error) {\n            // Collection doesn't exist so create index\n            if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                index = { files_id: 1, n: 1 };\n                stream.chunks.createIndex(index, { background: false, unique: true }, error => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    callback();\n                });\n                return;\n            }\n            return callback(error);\n        }\n        let hasChunksIndex = false;\n        if (indexes) {\n            indexes.forEach((index) => {\n                if (index.key) {\n                    const keys = Object.keys(index.key);\n                    if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n                        hasChunksIndex = true;\n                    }\n                }\n            });\n        }\n        if (hasChunksIndex) {\n            callback();\n        }\n        else {\n            index = { files_id: 1, n: 1 };\n            const writeConcernOptions = getWriteOptions(stream);\n            stream.chunks.createIndex(index, {\n                ...writeConcernOptions,\n                background: true,\n                unique: true\n            }, callback);\n        }\n    });\n}\nfunction checkDone(stream, callback) {\n    if (stream.done)\n        return true;\n    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {\n        // Set done so we do not trigger duplicate createFilesDoc\n        stream.done = true;\n        // Create a new files doc\n        const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);\n        if (checkAborted(stream, callback)) {\n            return false;\n        }\n        stream.files.insertOne(filesDoc, getWriteOptions(stream), (error) => {\n            if (error) {\n                return __handleError(stream, error, callback);\n            }\n            stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);\n            stream.emit(GridFSBucketWriteStream.CLOSE);\n        });\n        return true;\n    }\n    return false;\n}\nfunction checkIndexes(stream, callback) {\n    stream.files.findOne({}, { projection: { _id: 1 } }, (error, doc) => {\n        if (error) {\n            return callback(error);\n        }\n        if (doc) {\n            return callback();\n        }\n        stream.files.listIndexes().toArray((error, indexes) => {\n            let index;\n            if (error) {\n                // Collection doesn't exist so create index\n                if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                    index = { filename: 1, uploadDate: 1 };\n                    stream.files.createIndex(index, { background: false }, (error) => {\n                        if (error) {\n                            return callback(error);\n                        }\n                        checkChunksIndex(stream, callback);\n                    });\n                    return;\n                }\n                return callback(error);\n            }\n            let hasFileIndex = false;\n            if (indexes) {\n                indexes.forEach((index) => {\n                    const keys = Object.keys(index.key);\n                    if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n                        hasFileIndex = true;\n                    }\n                });\n            }\n            if (hasFileIndex) {\n                checkChunksIndex(stream, callback);\n            }\n            else {\n                index = { filename: 1, uploadDate: 1 };\n                const writeConcernOptions = getWriteOptions(stream);\n                stream.files.createIndex(index, {\n                    ...writeConcernOptions,\n                    background: false\n                }, (error) => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    checkChunksIndex(stream, callback);\n                });\n            }\n        });\n    });\n}\nfunction createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {\n    const ret = {\n        _id,\n        length,\n        chunkSize,\n        uploadDate: new Date(),\n        filename\n    };\n    if (contentType) {\n        ret.contentType = contentType;\n    }\n    if (aliases) {\n        ret.aliases = aliases;\n    }\n    if (metadata) {\n        ret.metadata = metadata;\n    }\n    return ret;\n}\nfunction doWrite(stream, chunk, encoding, callback) {\n    if (checkAborted(stream, callback)) {\n        return false;\n    }\n    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n    stream.length += inputBuf.length;\n    // Input is small enough to fit in our buffer\n    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {\n        inputBuf.copy(stream.bufToStore, stream.pos);\n        stream.pos += inputBuf.length;\n        callback && callback();\n        // Note that we reverse the typical semantics of write's return value\n        // to be compatible with node's `.pipe()` function.\n        // True means client can keep writing.\n        return true;\n    }\n    // Otherwise, buffer is too big for current chunk, so we need to flush\n    // to MongoDB.\n    let inputBufRemaining = inputBuf.length;\n    let spaceRemaining = stream.chunkSizeBytes - stream.pos;\n    let numToCopy = Math.min(spaceRemaining, inputBuf.length);\n    let outstandingRequests = 0;\n    while (inputBufRemaining > 0) {\n        const inputBufPos = inputBuf.length - inputBufRemaining;\n        inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);\n        stream.pos += numToCopy;\n        spaceRemaining -= numToCopy;\n        let doc;\n        if (spaceRemaining === 0) {\n            doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));\n            ++stream.state.outstandingRequests;\n            ++outstandingRequests;\n            if (checkAborted(stream, callback)) {\n                return false;\n            }\n            stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {\n                if (error) {\n                    return __handleError(stream, error);\n                }\n                --stream.state.outstandingRequests;\n                --outstandingRequests;\n                if (!outstandingRequests) {\n                    stream.emit('drain', doc);\n                    callback && callback();\n                    checkDone(stream);\n                }\n            });\n            spaceRemaining = stream.chunkSizeBytes;\n            stream.pos = 0;\n            ++stream.n;\n        }\n        inputBufRemaining -= numToCopy;\n        numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n    }\n    // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // False means the client should wait for the 'drain' event.\n    return false;\n}\nfunction getWriteOptions(stream) {\n    const obj = {};\n    if (stream.writeConcern) {\n        obj.writeConcern = {\n            w: stream.writeConcern.w,\n            wtimeout: stream.writeConcern.wtimeout,\n            j: stream.writeConcern.j\n        };\n    }\n    return obj;\n}\nfunction waitForIndexes(stream, callback) {\n    if (stream.bucket.s.checkedIndexes) {\n        return callback(false);\n    }\n    stream.bucket.once('index', () => {\n        callback(true);\n    });\n    return true;\n}\nfunction writeRemnant(stream, callback) {\n    // Buffer is empty, so don't bother to insert\n    if (stream.pos === 0) {\n        return checkDone(stream, callback);\n    }\n    ++stream.state.outstandingRequests;\n    // Create a new buffer to make sure the buffer isn't bigger than it needs\n    // to be.\n    const remnant = Buffer.alloc(stream.pos);\n    stream.bufToStore.copy(remnant, 0, 0, stream.pos);\n    const doc = createChunkDoc(stream.id, stream.n, remnant);\n    // If the stream was aborted, do not write remnant\n    if (checkAborted(stream, callback)) {\n        return false;\n    }\n    stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {\n        if (error) {\n            return __handleError(stream, error);\n        }\n        --stream.state.outstandingRequests;\n        checkDone(stream);\n    });\n    return true;\n}\nfunction checkAborted(stream, callback) {\n    if (stream.state.aborted) {\n        if (typeof callback === 'function') {\n            // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError\n            callback(new error_1.MongoAPIError('Stream has been aborted'));\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=upload.js.map"]},"metadata":{},"sourceType":"script"}