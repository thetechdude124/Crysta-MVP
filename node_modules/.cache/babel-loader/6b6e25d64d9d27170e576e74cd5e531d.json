{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.collectionNamespace = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.executeLegacyOperation = exports.filterOptions = exports.mergeOptions = exports.decorateCommand = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.getSingleProperty = exports.MAX_JS_INT = void 0;\nexports.parsePackageVersion = exports.supportsRetryableWrites = void 0;\n\nconst os = require(\"os\");\n\nconst crypto = require(\"crypto\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst error_1 = require(\"./error\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst bson_1 = require(\"./bson\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst url_1 = require(\"url\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Add a readonly enumerable property.\n * @internal\n */\n\nfunction getSingleProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n\n    get() {\n      return value;\n    }\n\n  });\n}\n\nexports.getSingleProperty = getSingleProperty;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\n\nfunction parseIndexOptions(indexSpec) {\n  const fieldHash = {};\n  const indexes = [];\n  let keys; // Get all the fields accordingly\n\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(f => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(([key, value]) => {\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction isObject(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction decorateCommand(command, options, exclude) {\n  for (const name in options) {\n    if (!exclude.includes(name)) {\n      command[name] = options[name];\n    }\n  }\n\n  return command;\n}\n\nexports.decorateCommand = decorateCommand;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\n\nfunction executeLegacyOperation(topology, operation, args, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n\n  if (!Array.isArray(args)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires an array of arguments to apply');\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session;\n  let opOptions;\n  let owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new error_1.MongoExpiredSessionError();\n    }\n  }\n\n  function makeExecuteCallback(resolve, reject) {\n    return function (err, result) {\n      if (session && session.owner === owner && !(options === null || options === void 0 ? void 0 : options.returnsCursor)) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n  } // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(undefined, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n}\n\nexports.executeLegacyOperation = executeLegacyOperation;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  var _a;\n\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\n\nfunction getTopology(provider) {\n  if (`topology` in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated(...args) {\n    const options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    } // interrupt the function call with a warning\n\n\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n\n    return fn.bind(this)(...args);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collection] = namespace.split('.');\n    return new MongoDBNamespace(db, collection.join('.'));\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter(seed = 0) {\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\n\nfunction maybePromise(callback, wrapper) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    callback(err, res);\n  });\n  return result;\n}\n\nexports.maybePromise = maybePromise;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/** @internal */\n\nfunction collectionNamespace(ns) {\n  return ns.split('.').slice(1).join('.');\n}\n\nexports.collectionNamespace = collectionNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\n\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n\n  const result = Object.assign({}, options, bson_1.resolveBSONOptions(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options === null || options === void 0 ? void 0 : options.session;\n\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nfunction isRecord(value, requiredKeys = undefined) {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  const isObject = v => toString.call(v) === '[object Object]';\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/** @internal */\n\nconst kBuffers = Symbol('buffers');\n/** @internal */\n\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  get length() {\n    return this[kLength];\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n  /** Returns the requested number of bytes without consuming them */\n\n\n  peek(size) {\n    return this.read(size, false);\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size, consume = true) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n\n    let result; // read the whole buffer\n\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    } // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    } // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n\n          offset += bytesCopied;\n          break;\n        }\n\n        bytesToCopy -= bytesCopied;\n      } // compact the internal buffer array\n\n\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    const {\n      hostname,\n      port\n    } = new url_1.URL(`mongodb://${escapedHost}`);\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n\n    Object.freeze(this);\n  }\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n\n\n  toString(ipv6Brackets = false) {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  return !!server.loadBalanced || server.description.maxWireVersion >= 6 && !!server.description.logicalSessionTimeoutMinutes && server.description.type !== common_1.ServerType.Standalone;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n\nfunction parsePackageVersion({\n  version\n}) {\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\n\nexports.parsePackageVersion = parsePackageVersion;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.collectionNamespace = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.executeLegacyOperation = exports.filterOptions = exports.mergeOptions = exports.decorateCommand = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.getSingleProperty = exports.MAX_JS_INT = void 0;\nexports.parsePackageVersion = exports.supportsRetryableWrites = void 0;\nconst os = require(\"os\");\nconst crypto = require(\"crypto\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst error_1 = require(\"./error\");\nconst write_concern_1 = require(\"./write_concern\");\nconst common_1 = require(\"./sdam/common\");\nconst read_concern_1 = require(\"./read_concern\");\nconst bson_1 = require(\"./bson\");\nconst read_preference_1 = require(\"./read_preference\");\nconst url_1 = require(\"url\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Add a readonly enumerable property.\n * @internal\n */\nfunction getSingleProperty(obj, name, value) {\n    Object.defineProperty(obj, name, {\n        enumerable: true,\n        get() {\n            return value;\n        }\n    });\n}\nexports.getSingleProperty = getSingleProperty;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nfunction checkCollectionName(collectionName) {\n    if ('string' !== typeof collectionName) {\n        throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n    }\n    if (!collectionName || collectionName.indexOf('..') !== -1) {\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n    }\n    if (collectionName.indexOf('$') !== -1 &&\n        collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n    }\n    if (collectionName.match(/^\\.|\\.$/) != null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n    }\n    // Validate that we are not passing 0x00 in the collection name\n    if (collectionName.indexOf('\\x00') !== -1) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n    }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n    let finalHint = undefined;\n    if (typeof hint === 'string') {\n        finalHint = hint;\n    }\n    else if (Array.isArray(hint)) {\n        finalHint = {};\n        hint.forEach(param => {\n            finalHint[param] = 1;\n        });\n    }\n    else if (hint != null && typeof hint === 'object') {\n        finalHint = {};\n        for (const name in hint) {\n            finalHint[name] = hint[name];\n        }\n    }\n    return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\nfunction parseIndexOptions(indexSpec) {\n    const fieldHash = {};\n    const indexes = [];\n    let keys;\n    // Get all the fields accordingly\n    if ('string' === typeof indexSpec) {\n        // 'type'\n        indexes.push(indexSpec + '_' + 1);\n        fieldHash[indexSpec] = 1;\n    }\n    else if (Array.isArray(indexSpec)) {\n        indexSpec.forEach((f) => {\n            if ('string' === typeof f) {\n                // [{location:'2d'}, 'type']\n                indexes.push(f + '_' + 1);\n                fieldHash[f] = 1;\n            }\n            else if (Array.isArray(f)) {\n                // [['location', '2d'],['type', 1]]\n                indexes.push(f[0] + '_' + (f[1] || 1));\n                fieldHash[f[0]] = f[1] || 1;\n            }\n            else if (isObject(f)) {\n                // [{location:'2d'}, {type:1}]\n                keys = Object.keys(f);\n                keys.forEach(k => {\n                    indexes.push(k + '_' + f[k]);\n                    fieldHash[k] = f[k];\n                });\n            }\n            else {\n                // undefined (ignore)\n            }\n        });\n    }\n    else if (isObject(indexSpec)) {\n        // {location:'2d', type:1}\n        keys = Object.keys(indexSpec);\n        Object.entries(indexSpec).forEach(([key, value]) => {\n            indexes.push(key + '_' + value);\n            fieldHash[key] = value;\n        });\n    }\n    return {\n        name: indexes.join('_'),\n        keys: keys,\n        fieldHash: fieldHash\n    };\n}\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isObject(arg) {\n    return '[object Object]' === Object.prototype.toString.call(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction decorateCommand(command, options, exclude) {\n    for (const name in options) {\n        if (!exclude.includes(name)) {\n            command[name] = options[name];\n        }\n    }\n    return command;\n}\nexports.decorateCommand = decorateCommand;\n/** @internal */\nfunction mergeOptions(target, source) {\n    return { ...target, ...source };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n    const filterOptions = {};\n    for (const name in options) {\n        if (names.includes(name)) {\n            filterOptions[name] = options[name];\n        }\n    }\n    // Filtered options\n    return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\nfunction executeLegacyOperation(topology, operation, args, options) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    if (!Array.isArray(args)) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('This method requires an array of arguments to apply');\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    let callback = args[args.length - 1];\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session;\n    let opOptions;\n    let owner;\n    if (!options.skipSessions && topology.hasSessionSupport()) {\n        opOptions = args[args.length - 2];\n        if (opOptions == null || opOptions.session == null) {\n            owner = Symbol();\n            session = topology.startSession({ owner });\n            const optionsIndex = args.length - 2;\n            args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n        }\n        else if (opOptions.session && opOptions.session.hasEnded) {\n            throw new error_1.MongoExpiredSessionError();\n        }\n    }\n    function makeExecuteCallback(resolve, reject) {\n        return function (err, result) {\n            if (session && session.owner === owner && !(options === null || options === void 0 ? void 0 : options.returnsCursor)) {\n                session.endSession(() => {\n                    delete opOptions.session;\n                    if (err)\n                        return reject(err);\n                    resolve(result);\n                });\n            }\n            else {\n                if (err)\n                    return reject(err);\n                resolve(result);\n            }\n        };\n    }\n    // Execute using callback\n    if (typeof callback === 'function') {\n        callback = args.pop();\n        const handler = makeExecuteCallback(result => callback(undefined, result), err => callback(err, null));\n        args.push(handler);\n        try {\n            return operation(...args);\n        }\n        catch (e) {\n            handler(e);\n            throw e;\n        }\n    }\n    // Return a Promise\n    if (args[args.length - 1] != null) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n    }\n    return new Promise((resolve, reject) => {\n        const handler = makeExecuteCallback(resolve, reject);\n        args[args.length - 1] = handler;\n        try {\n            return operation(...args);\n        }\n        catch (e) {\n            handler(e);\n        }\n    });\n}\nexports.executeLegacyOperation = executeLegacyOperation;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n    var _a;\n    if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n        target.retryWrites = true;\n    }\n    return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nfunction applyWriteConcern(target, sources, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const db = sources.db;\n    const coll = sources.collection;\n    if (options.session && options.session.inTransaction()) {\n        // writeConcern is not allowed within a multi-statement transaction\n        if (target.writeConcern) {\n            delete target.writeConcern;\n        }\n        return target;\n    }\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    if (writeConcern) {\n        return Object.assign(target, { writeConcern });\n    }\n    if (coll && coll.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n    }\n    if (db && db.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n    }\n    return target;\n}\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n    return !!maybePromise && typeof maybePromise.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n    const capabilities = getTopology(target).capabilities;\n    if (options.collation && typeof options.collation === 'object') {\n        if (capabilities && capabilities.commandsTakeCollation) {\n            command.collation = options.collation;\n        }\n        else {\n            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n        }\n    }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n    if (options && options.session && options.session.inTransaction()) {\n        return;\n    }\n    const readConcern = Object.assign({}, command.readConcern || {});\n    if (coll.s.readConcern) {\n        Object.assign(readConcern, coll.s.readConcern);\n    }\n    if (Object.keys(readConcern).length > 0) {\n        Object.assign(command, { readConcern: readConcern });\n    }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n    if (command.explain) {\n        return command;\n    }\n    return { explain: command, verbosity: explain.verbosity };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\nfunction getTopology(provider) {\n    if (`topology` in provider && provider.topology) {\n        return provider.topology;\n    }\n    else if ('client' in provider.s && provider.s.client.topology) {\n        return provider.s.client.topology;\n    }\n    else if ('db' in provider.s && provider.s.db.s.client.topology) {\n        return provider.s.db.s.client.topology;\n    }\n    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\nfunction defaultMsgHandler(name, option) {\n    return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\nfunction deprecateOptions(config, fn) {\n    if (process.noDeprecation === true) {\n        return fn;\n    }\n    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n    const optionsWarned = new Set();\n    function deprecated(...args) {\n        const options = args[config.optionsIndex];\n        // ensure options is a valid, non-empty object, otherwise short-circuit\n        if (!isObject(options) || Object.keys(options).length === 0) {\n            return fn.bind(this)(...args); // call the function, no change\n        }\n        // interrupt the function call with a warning\n        for (const deprecatedOption of config.deprecatedOptions) {\n            if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n                optionsWarned.add(deprecatedOption);\n                const msg = msgHandler(config.name, deprecatedOption);\n                emitWarning(msg);\n                if (this && 'getLogger' in this) {\n                    const logger = this.getLogger();\n                    if (logger) {\n                        logger.warn(msg);\n                    }\n                }\n            }\n        }\n        return fn.bind(this)(...args);\n    }\n    // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n    // The wrapper will keep the same prototype as fn to maintain prototype chain\n    Object.setPrototypeOf(deprecated, fn);\n    if (fn.prototype) {\n        // Setting this (rather than using Object.setPrototype, as above) ensures\n        // that calling the unwrapped constructor gives an instanceof the wrapped\n        // constructor.\n        deprecated.prototype = fn.prototype;\n    }\n    return deprecated;\n}\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\nfunction ns(ns) {\n    return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n    /**\n     * Create a namespace object\n     *\n     * @param db - database name\n     * @param collection - collection name\n     */\n    constructor(db, collection) {\n        this.db = db;\n        this.collection = collection;\n    }\n    toString() {\n        return this.collection ? `${this.db}.${this.collection}` : this.db;\n    }\n    withCollection(collection) {\n        return new MongoDBNamespace(this.db, collection);\n    }\n    static fromString(namespace) {\n        if (!namespace) {\n            // TODO(NODE-3483): Replace with MongoNamespaceError\n            throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n        }\n        const [db, ...collection] = namespace.split('.');\n        return new MongoDBNamespace(db, collection.join('.'));\n    }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction* makeCounter(seed = 0) {\n    let count = seed;\n    while (true) {\n        const newCount = count;\n        count += 1;\n        yield newCount;\n    }\n}\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(callback, wrapper) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    let result;\n    if (typeof callback !== 'function') {\n        result = new Promise((resolve, reject) => {\n            callback = (err, res) => {\n                if (err)\n                    return reject(err);\n                resolve(res);\n            };\n        });\n    }\n    wrapper((err, res) => {\n        if (err != null) {\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                callback(err);\n            }\n            catch (error) {\n                process.nextTick(() => {\n                    throw error;\n                });\n            }\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err, res);\n    });\n    return result;\n}\nexports.maybePromise = maybePromise;\n/** @internal */\nfunction databaseNamespace(ns) {\n    return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/** @internal */\nfunction collectionNamespace(ns) {\n    return ns.split('.').slice(1).join('.');\n}\nexports.collectionNamespace = collectionNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n    const result = crypto.randomBytes(16);\n    result[6] = (result[6] & 0x0f) | 0x40;\n    result[8] = (result[8] & 0x3f) | 0x80;\n    return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n    if (topologyOrServer) {\n        if (topologyOrServer.loadBalanced) {\n            // Since we do not have a monitor, we assume the load balanced server is always\n            // pointed at the latest mongodb version. There is a risk that for on-prem\n            // deployments that don't upgrade immediately that this could alert to the\n            // application that a feature is avaiable that is actually not.\n            return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n        }\n        if (topologyOrServer.ismaster) {\n            return topologyOrServer.ismaster.maxWireVersion;\n        }\n        if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n            const lastIsMaster = topologyOrServer.lastIsMaster();\n            if (lastIsMaster) {\n                return lastIsMaster.maxWireVersion;\n            }\n        }\n        if (topologyOrServer.description &&\n            'maxWireVersion' in topologyOrServer.description &&\n            topologyOrServer.description.maxWireVersion != null) {\n            return topologyOrServer.description.maxWireVersion;\n        }\n    }\n    return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\nfunction collationNotSupported(server, cmd) {\n    return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = 0;\n    for (idx = 0; idx < arr.length; ++idx) {\n        awaiting++;\n        eachFn(arr[idx], eachCallback);\n    }\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n        }\n    }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction eachAsyncSeries(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = arr.length;\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        idx++;\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n            return;\n        }\n        eachFn(arr[idx], eachCallback);\n    }\n    eachFn(arr[idx], eachCallback);\n}\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n    if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n        return false;\n    }\n    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n    if (lhs === rhs) {\n        return true;\n    }\n    if (!lhs || !rhs) {\n        return lhs === rhs;\n    }\n    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n        return false;\n    }\n    if (lhs.constructor.name !== rhs.constructor.name) {\n        return false;\n    }\n    if (lhs.message !== rhs.message) {\n        return false;\n    }\n    return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n    return function stateTransition(target, newState) {\n        const legalStates = stateTable[target.s.state];\n        if (legalStates && legalStates.indexOf(newState) < 0) {\n            throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n        }\n        target.emit('stateChanged', target.s.state, newState);\n        target.s.state = newState;\n    };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const metadata = {\n        driver: {\n            name: 'nodejs',\n            version: NODE_DRIVER_VERSION\n        },\n        os: {\n            type: os.type(),\n            name: process.platform,\n            architecture: process.arch,\n            version: os.release()\n        },\n        platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n    };\n    // support optionally provided wrapping driver info\n    if (options.driverInfo) {\n        if (options.driverInfo.name) {\n            metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n        }\n        if (options.driverInfo.version) {\n            metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n        }\n        if (options.driverInfo.platform) {\n            metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n        }\n    }\n    if (options.appName) {\n        // MongoDB requires the appName not exceed a byte length of 128\n        const buffer = Buffer.from(options.appName);\n        metadata.application = {\n            name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n        };\n    }\n    return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n    const hrtime = process.hrtime();\n    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n    if (typeof started !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n    }\n    const elapsed = now() - started;\n    return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\nfunction makeInterruptibleAsyncInterval(fn, options) {\n    let timerId;\n    let lastCallTime;\n    let lastWakeTime;\n    let stopped = false;\n    options = options !== null && options !== void 0 ? options : {};\n    const interval = options.interval || 1000;\n    const minInterval = options.minInterval || 500;\n    const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n    const clock = typeof options.clock === 'function' ? options.clock : now;\n    function wake() {\n        const currentTime = clock();\n        const timeSinceLastWake = currentTime - lastWakeTime;\n        const timeSinceLastCall = currentTime - lastCallTime;\n        const timeUntilNextCall = interval - timeSinceLastCall;\n        lastWakeTime = currentTime;\n        // For the streaming protocol: there is nothing obviously stopping this\n        // interval from being woken up again while we are waiting \"infinitely\"\n        // for `fn` to be called again`. Since the function effectively\n        // never completes, the `timeUntilNextCall` will continue to grow\n        // negatively unbounded, so it will never trigger a reschedule here.\n        // debounce multiple calls to wake within the `minInterval`\n        if (timeSinceLastWake < minInterval) {\n            return;\n        }\n        // reschedule a call as soon as possible, ensuring the call never happens\n        // faster than the `minInterval`\n        if (timeUntilNextCall > minInterval) {\n            reschedule(minInterval);\n        }\n        // This is possible in virtualized environments like AWS Lambda where our\n        // clock is unreliable. In these cases the timer is \"running\" but never\n        // actually completes, so we want to execute immediately and then attempt\n        // to reschedule.\n        if (timeUntilNextCall < 0) {\n            executeAndReschedule();\n        }\n    }\n    function stop() {\n        stopped = true;\n        if (timerId) {\n            clearTimeout(timerId);\n            timerId = undefined;\n        }\n        lastCallTime = 0;\n        lastWakeTime = 0;\n    }\n    function reschedule(ms) {\n        if (stopped)\n            return;\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(executeAndReschedule, ms || interval);\n    }\n    function executeAndReschedule() {\n        lastWakeTime = 0;\n        lastCallTime = clock();\n        fn(err => {\n            if (err)\n                throw err;\n            reschedule(interval);\n        });\n    }\n    if (immediate) {\n        executeAndReschedule();\n    }\n    else {\n        lastCallTime = clock();\n        reschedule(undefined);\n    }\n    return { wake, stop };\n}\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n    if (Array.isArray(doc)) {\n        for (const document of doc) {\n            if (hasAtomicOperators(document)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    const keys = Object.keys(doc);\n    return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n    var _a, _b, _c;\n    const result = Object.assign({}, options, bson_1.resolveBSONOptions(options, parent));\n    // Users cannot pass a readConcern/writeConcern to operations in a transaction\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n        const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n        if (readConcern) {\n            result.readConcern = readConcern;\n        }\n        const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n        if (writeConcern) {\n            result.writeConcern = writeConcern;\n        }\n    }\n    const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n    if (readPreference) {\n        result.readPreference = readPreference;\n    }\n    return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n    set = Array.isArray(set) ? new Set(set) : set;\n    subset = Array.isArray(subset) ? new Set(subset) : subset;\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSuperset = isSuperset;\nfunction setDifference(setA, setB) {\n    const difference = new Set(setA);\n    for (const elem of setB) {\n        difference.delete(elem);\n    }\n    return difference;\n}\nexports.setDifference = setDifference;\nfunction isRecord(value, requiredKeys = undefined) {\n    const toString = Object.prototype.toString;\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    const isObject = (v) => toString.call(v) === '[object Object]';\n    if (!isObject(value)) {\n        return false;\n    }\n    const ctor = value.constructor;\n    if (ctor && ctor.prototype) {\n        if (!isObject(ctor.prototype)) {\n            return false;\n        }\n        // Check to see if some method exists from the Object exists\n        if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n            return false;\n        }\n    }\n    if (requiredKeys) {\n        const keys = Object.keys(value);\n        return isSuperset(keys, requiredKeys);\n    }\n    return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n    if (value == null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        return value.map(item => deepCopy(item));\n    }\n    else if (isRecord(value)) {\n        const res = {};\n        for (const key in value) {\n            res[key] = deepCopy(value[key]);\n        }\n        return res;\n    }\n    const ctor = value.constructor;\n    if (ctor) {\n        switch (ctor.name.toLowerCase()) {\n            case 'date':\n                return new ctor(Number(value));\n            case 'map':\n                return new Map(value);\n            case 'set':\n                return new Set(value);\n            case 'buffer':\n                return Buffer.from(value);\n        }\n    }\n    return value;\n}\nexports.deepCopy = deepCopy;\n/** @internal */\nconst kBuffers = Symbol('buffers');\n/** @internal */\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nclass BufferPool {\n    constructor() {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n    }\n    get length() {\n        return this[kLength];\n    }\n    /** Adds a buffer to the internal buffer pool list */\n    append(buffer) {\n        this[kBuffers].push(buffer);\n        this[kLength] += buffer.length;\n    }\n    /** Returns the requested number of bytes without consuming them */\n    peek(size) {\n        return this.read(size, false);\n    }\n    /** Reads the requested number of bytes, optionally consuming them */\n    read(size, consume = true) {\n        if (typeof size !== 'number' || size < 0) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n        }\n        if (size > this[kLength]) {\n            return Buffer.alloc(0);\n        }\n        let result;\n        // read the whole buffer\n        if (size === this.length) {\n            result = Buffer.concat(this[kBuffers]);\n            if (consume) {\n                this[kBuffers] = [];\n                this[kLength] = 0;\n            }\n        }\n        // size is within first buffer, no need to concat\n        else if (size <= this[kBuffers][0].length) {\n            result = this[kBuffers][0].slice(0, size);\n            if (consume) {\n                this[kBuffers][0] = this[kBuffers][0].slice(size);\n                this[kLength] -= size;\n            }\n        }\n        // size is beyond first buffer, need to track and copy\n        else {\n            result = Buffer.allocUnsafe(size);\n            let idx;\n            let offset = 0;\n            let bytesToCopy = size;\n            for (idx = 0; idx < this[kBuffers].length; ++idx) {\n                let bytesCopied;\n                if (bytesToCopy > this[kBuffers][idx].length) {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n                    offset += bytesCopied;\n                }\n                else {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n                    if (consume) {\n                        this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n                    }\n                    offset += bytesCopied;\n                    break;\n                }\n                bytesToCopy -= bytesCopied;\n            }\n            // compact the internal buffer array\n            if (consume) {\n                this[kBuffers] = this[kBuffers].slice(idx);\n                this[kLength] -= size;\n            }\n        }\n        return result;\n    }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n    constructor(hostString) {\n        const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n        const { hostname, port } = new url_1.URL(`mongodb://${escapedHost}`);\n        if (hostname.endsWith('.sock')) {\n            // heuristically determine if we're working with a domain socket\n            this.socketPath = decodeURIComponent(hostname);\n        }\n        else if (typeof hostname === 'string') {\n            this.isIPv6 = false;\n            let normalized = decodeURIComponent(hostname).toLowerCase();\n            if (normalized.startsWith('[') && normalized.endsWith(']')) {\n                this.isIPv6 = true;\n                normalized = normalized.substring(1, hostname.length - 1);\n            }\n            this.host = normalized.toLowerCase();\n            if (typeof port === 'number') {\n                this.port = port;\n            }\n            else if (typeof port === 'string' && port !== '') {\n                this.port = Number.parseInt(port, 10);\n            }\n            else {\n                this.port = 27017;\n            }\n            if (this.port === 0) {\n                throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n            }\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n        }\n        Object.freeze(this);\n    }\n    /**\n     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n     */\n    toString(ipv6Brackets = false) {\n        if (typeof this.host === 'string') {\n            if (this.isIPv6 && ipv6Brackets) {\n                return `[${this.host}]:${this.port}`;\n            }\n            return `${this.host}:${this.port}`;\n        }\n        return `${this.socketPath}`;\n    }\n    static fromString(s) {\n        return new HostAddress(s);\n    }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n    // We prefer not to rely on ObjectId having a createPk method\n    createPk() {\n        return new bson_1.ObjectId();\n    }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n    if (!emittedWarnings.has(message)) {\n        emittedWarnings.add(message);\n        return emitWarning(message);\n    }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n    return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n    return (!!server.loadBalanced ||\n        (server.description.maxWireVersion >= 6 &&\n            !!server.description.logicalSessionTimeoutMinutes &&\n            server.description.type !== common_1.ServerType.Standalone));\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\nfunction parsePackageVersion({ version }) {\n    const [major, minor, patch] = version.split('.').map((n) => Number.parseInt(n, 10));\n    return { major, minor, patch };\n}\nexports.parsePackageVersion = parsePackageVersion;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}