{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nconst db_1 = require(\"./db\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst error_1 = require(\"./error\");\n\nconst utils_1 = require(\"./utils\");\n\nconst connect_1 = require(\"./operations/connect\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst bson_1 = require(\"./bson\");\n\nconst connection_string_1 = require(\"./connection_string\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = connection_string_1.parseOptions(url, this, options); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const client = this; // The internal state\n\n    this.s = {\n      url,\n      sessions: new Set(),\n      bsonOptions: bson_1.resolveBSONOptions(this[kOptions]),\n      namespace: utils_1.ns('admin'),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get logger() {\n        return client[kOptions].logger;\n      }\n\n    };\n  }\n\n  get options() {\n    return Object.freeze({ ...this[kOptions]\n    });\n  }\n\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n\n\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get readPreference() {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n\n  get logger() {\n    return this.s.logger;\n  }\n\n  connect(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n\n    return utils_1.maybePromise(callback, cb => {\n      connect_1.connect(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n\n  close(forceOrCallback, callback) {\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return utils_1.maybePromise(callback, callback => {\n      if (this.topology == null) {\n        return callback();\n      } // clear out references to old topology\n\n\n      const topology = this.topology;\n      this.topology = undefined;\n      topology.close({\n        force\n      }, error => {\n        if (error) return callback(error);\n        const {\n          encrypter\n        } = this[kOptions];\n\n        if (encrypter) {\n          return encrypter.close(this, force, error => {\n            callback(error);\n          });\n        }\n\n        callback();\n      });\n    });\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n\n\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided\n\n    if (!dbName) {\n      dbName = this.options.dbName;\n    } // Copy the options and add out internal override of the not shared flag\n\n\n    const finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n    const db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n    return db;\n  }\n\n  static connect(url, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options); // Execute the connect method\n\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n    }\n  }\n\n  startSession(options) {\n    options = Object.assign({\n      explicit: true\n    }, options);\n\n    if (!this.topology) {\n      throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n    }\n\n    return this.topology.startSession(options, this.s.options);\n  }\n\n  withSession(optionsOrOperation, callback) {\n    let options = optionsOrOperation;\n\n    if (typeof optionsOrOperation === 'function') {\n      callback = optionsOrOperation;\n      options = {\n        owner: Symbol()\n      };\n    }\n\n    if (callback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n\n    const session = this.startSession(options);\n    const Promise = promise_provider_1.PromiseProvider.get();\n\n    let cleanupHandler = (err, result, opts) => {\n      // prevent multiple calls to cleanupHandler\n      cleanupHandler = () => {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n      };\n\n      opts = Object.assign({\n        throw: true\n      }, opts);\n      session.endSession();\n\n      if (err) {\n        if (opts.throw) throw err;\n        return Promise.reject(err);\n      }\n    };\n\n    try {\n      const result = callback(session);\n      return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, {\n        throw: true\n      }));\n    } catch (err) {\n      return cleanupHandler(err, null, {\n        throw: false\n      });\n    }\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /** Return the mongo client logger */\n\n\n  getLogger() {\n    return this.s.logger;\n  }\n\n}\n\nexports.MongoClient = MongoClient;","map":{"version":3,"sources":["../src/mongo_client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst db_1 = require(\"./db\");\nconst change_stream_1 = require(\"./change_stream\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst connect_1 = require(\"./operations/connect\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst bson_1 = require(\"./bson\");\nconst connection_string_1 = require(\"./connection_string\");\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n    v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n    constructor(url, options) {\n        super();\n        this[kOptions] = connection_string_1.parseOptions(url, this, options);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const client = this;\n        // The internal state\n        this.s = {\n            url,\n            sessions: new Set(),\n            bsonOptions: bson_1.resolveBSONOptions(this[kOptions]),\n            namespace: utils_1.ns('admin'),\n            get options() {\n                return client[kOptions];\n            },\n            get readConcern() {\n                return client[kOptions].readConcern;\n            },\n            get writeConcern() {\n                return client[kOptions].writeConcern;\n            },\n            get readPreference() {\n                return client[kOptions].readPreference;\n            },\n            get logger() {\n                return client[kOptions].logger;\n            }\n        };\n    }\n    get options() {\n        return Object.freeze({ ...this[kOptions] });\n    }\n    get serverApi() {\n        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n    get monitorCommands() {\n        return this[kOptions].monitorCommands;\n    }\n    set monitorCommands(value) {\n        this[kOptions].monitorCommands = value;\n    }\n    get autoEncrypter() {\n        return this[kOptions].autoEncrypter;\n    }\n    get readConcern() {\n        return this.s.readConcern;\n    }\n    get writeConcern() {\n        return this.s.writeConcern;\n    }\n    get readPreference() {\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    get logger() {\n        return this.s.logger;\n    }\n    connect(callback) {\n        if (callback && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n        }\n        return utils_1.maybePromise(callback, cb => {\n            connect_1.connect(this, this[kOptions], err => {\n                if (err)\n                    return cb(err);\n                cb(undefined, this);\n            });\n        });\n    }\n    close(forceOrCallback, callback) {\n        if (typeof forceOrCallback === 'function') {\n            callback = forceOrCallback;\n        }\n        const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n        return utils_1.maybePromise(callback, callback => {\n            if (this.topology == null) {\n                return callback();\n            }\n            // clear out references to old topology\n            const topology = this.topology;\n            this.topology = undefined;\n            topology.close({ force }, error => {\n                if (error)\n                    return callback(error);\n                const { encrypter } = this[kOptions];\n                if (encrypter) {\n                    return encrypter.close(this, force, error => {\n                        callback(error);\n                    });\n                }\n                callback();\n            });\n        });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n    db(dbName, options) {\n        options = options !== null && options !== void 0 ? options : {};\n        // Default to db from connection string if not provided\n        if (!dbName) {\n            dbName = this.options.dbName;\n        }\n        // Copy the options and add out internal override of the not shared flag\n        const finalOptions = Object.assign({}, this[kOptions], options);\n        // Return the db object\n        const db = new db_1.Db(this, dbName, finalOptions);\n        // Return the database\n        return db;\n    }\n    static connect(url, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        try {\n            // Create client\n            const mongoClient = new MongoClient(url, options);\n            // Execute the connect method\n            if (callback) {\n                return mongoClient.connect(callback);\n            }\n            else {\n                return mongoClient.connect();\n            }\n        }\n        catch (error) {\n            if (callback)\n                return callback(error);\n            else\n                return promise_provider_1.PromiseProvider.get().reject(error);\n        }\n    }\n    startSession(options) {\n        options = Object.assign({ explicit: true }, options);\n        if (!this.topology) {\n            throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n        }\n        return this.topology.startSession(options, this.s.options);\n    }\n    withSession(optionsOrOperation, callback) {\n        let options = optionsOrOperation;\n        if (typeof optionsOrOperation === 'function') {\n            callback = optionsOrOperation;\n            options = { owner: Symbol() };\n        }\n        if (callback == null) {\n            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n        }\n        const session = this.startSession(options);\n        const Promise = promise_provider_1.PromiseProvider.get();\n        let cleanupHandler = ((err, result, opts) => {\n            // prevent multiple calls to cleanupHandler\n            cleanupHandler = () => {\n                // TODO(NODE-3483)\n                throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n            };\n            opts = Object.assign({ throw: true }, opts);\n            session.endSession();\n            if (err) {\n                if (opts.throw)\n                    throw err;\n                return Promise.reject(err);\n            }\n        });\n        try {\n            const result = callback(session);\n            return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, { throw: true }));\n        }\n        catch (err) {\n            return cleanupHandler(err, null, { throw: false });\n        }\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n    }\n    /** Return the mongo client logger */\n    getLogger() {\n        return this.s.logger;\n    }\n}\nexports.MongoClient = MongoClient;\n//# sourceMappingURL=mongo_client.js.map"]},"metadata":{},"sourceType":"script"}