{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\n\nconst commands_1 = require(\"./commands\");\n\nconst utils_1 = require(\"../utils\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   */\n  constructor(connection, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection); // TODO: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.databaseName = databaseName(command);\n    this.commandName = commandName;\n    this.command = maybeRedact(commandName, cmd, cmd);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param reply - the reply for this command from the server\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = utils_1.calculateDurationInMs(started);\n    this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param error - the generated error or a server error response\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = utils_1.calculateDurationInMs(started);\n    this.failure = maybeRedact(commandName, cmd, error);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\n\nfunction extractCommand(command) {\n  var _a;\n\n  if (command instanceof commands_1.GetMore) {\n    return {\n      getMore: utils_1.deepCopy(command.cursorId),\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof commands_1.KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: utils_1.deepCopy(command.cursorIds)\n    };\n  }\n\n  if (command instanceof commands_1.Msg) {\n    return utils_1.deepCopy(command.command);\n  }\n\n  if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // up-convert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // up-convert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (command.query[key] != null) {\n          result[LEGACY_FIND_QUERY_MAP[key]] = utils_1.deepCopy(command.query[key]);\n        }\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      const legacyKey = key;\n\n      if (command[legacyKey] != null) {\n        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = utils_1.deepCopy(command[legacyKey]);\n      }\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      const opKey = key;\n\n      if (command[opKey]) {\n        result[opKey] = command[opKey];\n      }\n    });\n\n    if (command.pre32Limit != null) {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  const clonedQuery = {};\n  const clonedCommand = {};\n\n  if (command.query) {\n    for (const k in command.query) {\n      clonedQuery[k] = utils_1.deepCopy(command.query[k]);\n    }\n\n    clonedCommand.query = clonedQuery;\n  }\n\n  for (const k in command) {\n    if (k === 'query') continue;\n    clonedCommand[k] = utils_1.deepCopy(command[k]);\n  }\n\n  return command.query ? clonedQuery : clonedCommand;\n}\n\nfunction extractReply(command, reply) {\n  if (command instanceof commands_1.KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  }\n\n  if (!reply) {\n    return reply;\n  }\n\n  if (command instanceof commands_1.GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: utils_1.deepCopy(reply.cursorId),\n        ns: namespace(command),\n        nextBatch: utils_1.deepCopy(reply.documents)\n      }\n    };\n  }\n\n  if (command instanceof commands_1.Msg) {\n    return utils_1.deepCopy(reply.result ? reply.result : reply);\n  } // is this a legacy find command?\n\n\n  if (command.query && command.query.$query != null) {\n    return {\n      ok: 1,\n      cursor: {\n        id: utils_1.deepCopy(reply.cursorId),\n        ns: namespace(command),\n        firstBatch: utils_1.deepCopy(reply.documents)\n      }\n    };\n  }\n\n  return utils_1.deepCopy(reply.result ? reply.result : reply);\n}\n\nfunction extractConnectionDetails(connection) {\n  let connectionId;\n\n  if ('id' in connection) {\n    connectionId = connection.id;\n  }\n\n  return {\n    address: connection.address,\n    serviceId: connection.serviceId,\n    connectionId\n  };\n}","map":{"version":3,"sources":["../../src/cmap/command_monitoring_events.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\nconst commands_1 = require(\"./commands\");\nconst utils_1 = require(\"../utils\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\nclass CommandStartedEvent {\n    /**\n     * Create a started event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     */\n    constructor(connection, command) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        // TODO: remove in major revision, this is not spec behavior\n        if (SENSITIVE_COMMANDS.has(commandName)) {\n            this.commandObj = {};\n            this.commandObj[commandName] = true;\n        }\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.databaseName = databaseName(command);\n        this.commandName = commandName;\n        this.command = maybeRedact(commandName, cmd, cmd);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\nclass CommandSucceededEvent {\n    /**\n     * Create a succeeded event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param reply - the reply for this command from the server\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, reply, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = utils_1.calculateDurationInMs(started);\n        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\nclass CommandFailedEvent {\n    /**\n     * Create a failure event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param error - the generated error or a server error response\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, error, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = utils_1.calculateDurationInMs(started);\n        this.failure = maybeRedact(commandName, cmd, error);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n    'authenticate',\n    'saslStart',\n    'saslContinue',\n    'getnonce',\n    'createUser',\n    'updateUser',\n    'copydbgetnonce',\n    'copydbsaslstart',\n    'copydb'\n]);\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']);\n// helper methods\nconst extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];\nconst namespace = (command) => command.ns;\nconst databaseName = (command) => command.ns.split('.')[0];\nconst collectionName = (command) => command.ns.split('.')[1];\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) ||\n    (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)\n    ? {}\n    : result;\nconst LEGACY_FIND_QUERY_MAP = {\n    $query: 'filter',\n    $orderby: 'sort',\n    $hint: 'hint',\n    $comment: 'comment',\n    $maxScan: 'maxScan',\n    $max: 'max',\n    $min: 'min',\n    $returnKey: 'returnKey',\n    $showDiskLoc: 'showRecordId',\n    $maxTimeMS: 'maxTimeMS',\n    $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n    numberToSkip: 'skip',\n    numberToReturn: 'batchSize',\n    returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'partial',\n    'exhaust'\n];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\nfunction extractCommand(command) {\n    var _a;\n    if (command instanceof commands_1.GetMore) {\n        return {\n            getMore: utils_1.deepCopy(command.cursorId),\n            collection: collectionName(command),\n            batchSize: command.numberToReturn\n        };\n    }\n    if (command instanceof commands_1.KillCursor) {\n        return {\n            killCursors: collectionName(command),\n            cursors: utils_1.deepCopy(command.cursorIds)\n        };\n    }\n    if (command instanceof commands_1.Msg) {\n        return utils_1.deepCopy(command.command);\n    }\n    if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n        let result;\n        if (command.ns === 'admin.$cmd') {\n            // up-convert legacy command\n            result = Object.assign({}, command.query.$query);\n        }\n        else {\n            // up-convert legacy find command\n            result = { find: collectionName(command) };\n            Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n                if (command.query[key] != null) {\n                    result[LEGACY_FIND_QUERY_MAP[key]] = utils_1.deepCopy(command.query[key]);\n                }\n            });\n        }\n        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n            const legacyKey = key;\n            if (command[legacyKey] != null) {\n                result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = utils_1.deepCopy(command[legacyKey]);\n            }\n        });\n        OP_QUERY_KEYS.forEach(key => {\n            const opKey = key;\n            if (command[opKey]) {\n                result[opKey] = command[opKey];\n            }\n        });\n        if (command.pre32Limit != null) {\n            result.limit = command.pre32Limit;\n        }\n        if (command.query.$explain) {\n            return { explain: result };\n        }\n        return result;\n    }\n    const clonedQuery = {};\n    const clonedCommand = {};\n    if (command.query) {\n        for (const k in command.query) {\n            clonedQuery[k] = utils_1.deepCopy(command.query[k]);\n        }\n        clonedCommand.query = clonedQuery;\n    }\n    for (const k in command) {\n        if (k === 'query')\n            continue;\n        clonedCommand[k] = utils_1.deepCopy(command[k]);\n    }\n    return command.query ? clonedQuery : clonedCommand;\n}\nfunction extractReply(command, reply) {\n    if (command instanceof commands_1.KillCursor) {\n        return {\n            ok: 1,\n            cursorsUnknown: command.cursorIds\n        };\n    }\n    if (!reply) {\n        return reply;\n    }\n    if (command instanceof commands_1.GetMore) {\n        return {\n            ok: 1,\n            cursor: {\n                id: utils_1.deepCopy(reply.cursorId),\n                ns: namespace(command),\n                nextBatch: utils_1.deepCopy(reply.documents)\n            }\n        };\n    }\n    if (command instanceof commands_1.Msg) {\n        return utils_1.deepCopy(reply.result ? reply.result : reply);\n    }\n    // is this a legacy find command?\n    if (command.query && command.query.$query != null) {\n        return {\n            ok: 1,\n            cursor: {\n                id: utils_1.deepCopy(reply.cursorId),\n                ns: namespace(command),\n                firstBatch: utils_1.deepCopy(reply.documents)\n            }\n        };\n    }\n    return utils_1.deepCopy(reply.result ? reply.result : reply);\n}\nfunction extractConnectionDetails(connection) {\n    let connectionId;\n    if ('id' in connection) {\n        connectionId = connection.id;\n    }\n    return {\n        address: connection.address,\n        serviceId: connection.serviceId,\n        connectionId\n    };\n}\n//# sourceMappingURL=command_monitoring_events.js.map"]},"metadata":{},"sourceType":"script"}