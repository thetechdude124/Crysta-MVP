{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesCursor = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\n\nconst execute_operation_1 = require(\"./execute_operation\");\n\nconst LIST_INDEXES_WIRE_VERSION = 3;\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction makeIndexSpec(indexSpec, options) {\n  const indexParameters = utils_1.parseIndexOptions(indexSpec); // Generate the index name\n\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const finalIndexSpec = {\n    name,\n    key: indexParameters.fieldHash\n  }; // merge valid index options into the index spec\n\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec;\n}\n/** @internal */\n\n\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    common_functions_1.indexInformation(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = utils_1.maxWireVersion(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` + 'does not support collation'));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n\n}\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n\n}\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n\n}\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n\n}\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n\n}\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server, session, callback) {\n    const serverWireVersion = utils_1.maxWireVersion(server);\n\n    if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {\n      const systemIndexesNS = this.collectionNamespace.withCollection('system.indexes');\n      const collectionNS = this.collectionNamespace.toString();\n      server.query(systemIndexesNS, {\n        query: {\n          ns: collectionNS\n        }\n      }, { ...this.options,\n        readPreference: this.readPreference\n      }, callback);\n      return;\n    }\n\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    super.executeCommand(server, session, {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }, callback);\n  }\n\n}\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @public */\n\nclass ListIndexesCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(collection, options) {\n    super(utils_1.getTopology(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n\n  clone() {\n    return new ListIndexesCursor(this.parent, { ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const operation = new ListIndexesOperation(this.parent, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    execute_operation_1.executeOperation(utils_1.getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n\n}\n\nexports.ListIndexesCursor = ListIndexesCursor;\n/** @internal */\n\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    common_functions_1.indexInformation(coll.s.db, coll.collectionName, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err); // Let's check for the index names\n\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      } // All keys found return true\n\n\n      return callback(undefined, true);\n    });\n  }\n\n}\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    common_functions_1.indexInformation(db, name, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexInformationOperation = IndexInformationOperation;\noperation_1.defineAspects(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\noperation_1.defineAspects(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["../../src/operations/indexes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesCursor = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst read_preference_1 = require(\"../read_preference\");\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\nconst execute_operation_1 = require(\"./execute_operation\");\nconst LIST_INDEXES_WIRE_VERSION = 3;\nconst VALID_INDEX_OPTIONS = new Set([\n    'background',\n    'unique',\n    'name',\n    'partialFilterExpression',\n    'sparse',\n    'hidden',\n    'expireAfterSeconds',\n    'storageEngine',\n    'collation',\n    'version',\n    // text indexes\n    'weights',\n    'default_language',\n    'language_override',\n    'textIndexVersion',\n    // 2d-sphere indexes\n    '2dsphereIndexVersion',\n    // 2d indexes\n    'bits',\n    'min',\n    'max',\n    // geoHaystack Indexes\n    'bucketSize',\n    // wildcard indexes\n    'wildcardProjection'\n]);\nfunction makeIndexSpec(indexSpec, options) {\n    const indexParameters = utils_1.parseIndexOptions(indexSpec);\n    // Generate the index name\n    const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n    // Set up the index\n    const finalIndexSpec = { name, key: indexParameters.fieldHash };\n    // merge valid index options into the index spec\n    for (const optionName in options) {\n        if (VALID_INDEX_OPTIONS.has(optionName)) {\n            finalIndexSpec[optionName] = options[optionName];\n        }\n    }\n    return finalIndexSpec;\n}\n/** @internal */\nclass IndexesOperation extends operation_1.AbstractOperation {\n    constructor(collection, options) {\n        super(options);\n        this.options = options;\n        this.collection = collection;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const options = this.options;\n        common_functions_1.indexInformation(coll.s.db, coll.collectionName, { full: true, ...options, readPreference: this.readPreference, session }, callback);\n    }\n}\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nclass CreateIndexesOperation extends command_1.CommandOperation {\n    constructor(parent, collectionName, indexes, options) {\n        super(parent, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collectionName = collectionName;\n        this.indexes = indexes;\n    }\n    execute(server, session, callback) {\n        const options = this.options;\n        const indexes = this.indexes;\n        const serverWireVersion = utils_1.maxWireVersion(server);\n        // Ensure we generate the correct name if the parameter is not set\n        for (let i = 0; i < indexes.length; i++) {\n            // Did the user pass in a collation, check if our write server supports it\n            if (indexes[i].collation && serverWireVersion < 5) {\n                callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` +\n                    'does not support collation'));\n                return;\n            }\n            if (indexes[i].name == null) {\n                const keys = [];\n                for (const name in indexes[i].key) {\n                    keys.push(`${name}_${indexes[i].key[name]}`);\n                }\n                // Set the name\n                indexes[i].name = keys.join('_');\n            }\n        }\n        const cmd = { createIndexes: this.collectionName, indexes };\n        if (options.commitQuorum != null) {\n            if (serverWireVersion < 9) {\n                callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n                return;\n            }\n            cmd.commitQuorum = options.commitQuorum;\n        }\n        // collation is set on each index, it should not be defined at the root\n        this.options.collation = undefined;\n        super.executeCommand(server, session, cmd, err => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            const indexNames = indexes.map(index => index.name || '');\n            callback(undefined, indexNames);\n        });\n    }\n}\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nclass CreateIndexOperation extends CreateIndexesOperation {\n    constructor(parent, collectionName, indexSpec, options) {\n        // createIndex can be called with a variety of styles:\n        //   coll.createIndex('a');\n        //   coll.createIndex({ a: 1 });\n        //   coll.createIndex([['a', 1]]);\n        // createIndexes is always called with an array of index spec objects\n        super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n    }\n    execute(server, session, callback) {\n        super.execute(server, session, (err, indexNames) => {\n            if (err || !indexNames)\n                return callback(err);\n            return callback(undefined, indexNames[0]);\n        });\n    }\n}\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nclass EnsureIndexOperation extends CreateIndexOperation {\n    constructor(db, collectionName, indexSpec, options) {\n        super(db, collectionName, indexSpec, options);\n        this.readPreference = read_preference_1.ReadPreference.primary;\n        this.db = db;\n        this.collectionName = collectionName;\n    }\n    execute(server, session, callback) {\n        const indexName = this.indexes[0].name;\n        const cursor = this.db.collection(this.collectionName).listIndexes({ session });\n        cursor.toArray((err, indexes) => {\n            /// ignore \"NamespaceNotFound\" errors\n            if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                return callback(err);\n            }\n            if (indexes) {\n                indexes = Array.isArray(indexes) ? indexes : [indexes];\n                if (indexes.some(index => index.name === indexName)) {\n                    callback(undefined, indexName);\n                    return;\n                }\n            }\n            super.execute(server, session, callback);\n        });\n    }\n}\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nclass DropIndexOperation extends command_1.CommandOperation {\n    constructor(collection, indexName, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collection = collection;\n        this.indexName = indexName;\n    }\n    execute(server, session, callback) {\n        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n        super.executeCommand(server, session, cmd, callback);\n    }\n}\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nclass DropIndexesOperation extends DropIndexOperation {\n    constructor(collection, options) {\n        super(collection, '*', options);\n    }\n    execute(server, session, callback) {\n        super.execute(server, session, err => {\n            if (err)\n                return callback(err, false);\n            callback(undefined, true);\n        });\n    }\n}\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nclass ListIndexesOperation extends command_1.CommandOperation {\n    constructor(collection, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collectionNamespace = collection.s.namespace;\n    }\n    execute(server, session, callback) {\n        const serverWireVersion = utils_1.maxWireVersion(server);\n        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {\n            const systemIndexesNS = this.collectionNamespace.withCollection('system.indexes');\n            const collectionNS = this.collectionNamespace.toString();\n            server.query(systemIndexesNS, { query: { ns: collectionNS } }, { ...this.options, readPreference: this.readPreference }, callback);\n            return;\n        }\n        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n        super.executeCommand(server, session, { listIndexes: this.collectionNamespace.collection, cursor }, callback);\n    }\n}\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @public */\nclass ListIndexesCursor extends abstract_cursor_1.AbstractCursor {\n    constructor(collection, options) {\n        super(utils_1.getTopology(collection), collection.s.namespace, options);\n        this.parent = collection;\n        this.options = options;\n    }\n    clone() {\n        return new ListIndexesCursor(this.parent, {\n            ...this.options,\n            ...this.cursorOptions\n        });\n    }\n    /** @internal */\n    _initialize(session, callback) {\n        const operation = new ListIndexesOperation(this.parent, {\n            ...this.cursorOptions,\n            ...this.options,\n            session\n        });\n        execute_operation_1.executeOperation(utils_1.getTopology(this.parent), operation, (err, response) => {\n            if (err || response == null)\n                return callback(err);\n            // TODO: NODE-2882\n            callback(undefined, { server: operation.server, session, response });\n        });\n    }\n}\nexports.ListIndexesCursor = ListIndexesCursor;\n/** @internal */\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n    constructor(collection, indexes, options) {\n        super(options);\n        this.options = options;\n        this.collection = collection;\n        this.indexes = indexes;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const indexes = this.indexes;\n        common_functions_1.indexInformation(coll.s.db, coll.collectionName, { ...this.options, readPreference: this.readPreference, session }, (err, indexInformation) => {\n            // If we have an error return\n            if (err != null)\n                return callback(err);\n            // Let's check for the index names\n            if (!Array.isArray(indexes))\n                return callback(undefined, indexInformation[indexes] != null);\n            // Check in list of indexes\n            for (let i = 0; i < indexes.length; i++) {\n                if (indexInformation[indexes[i]] == null) {\n                    return callback(undefined, false);\n                }\n            }\n            // All keys found return true\n            return callback(undefined, true);\n        });\n    }\n}\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n    constructor(db, name, options) {\n        super(options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.db = db;\n        this.name = name;\n    }\n    execute(server, session, callback) {\n        const db = this.db;\n        const name = this.name;\n        common_functions_1.indexInformation(db, name, { ...this.options, readPreference: this.readPreference, session }, callback);\n    }\n}\nexports.IndexInformationOperation = IndexInformationOperation;\noperation_1.defineAspects(ListIndexesOperation, [\n    operation_1.Aspect.READ_OPERATION,\n    operation_1.Aspect.RETRYABLE,\n    operation_1.Aspect.CURSOR_CREATING\n]);\noperation_1.defineAspects(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=indexes.js.map"]},"metadata":{},"sourceType":"script"}