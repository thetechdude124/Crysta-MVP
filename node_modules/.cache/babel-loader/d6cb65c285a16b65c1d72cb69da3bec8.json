{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\n\nconst aggregate_1 = require(\"../operations/aggregate\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst utils_1 = require(\"../utils\");\n/** @internal */\n\n\nconst kPipeline = Symbol('pipeline');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\n\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(topology, namespace, pipeline = [], options = {}) {\n    super(topology, namespace, options);\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n\n  get pipeline() {\n    return this[kPipeline];\n  }\n\n  clone() {\n    const clonedOptions = utils_1.mergeOptions({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.topology, this.namespace, this[kPipeline], { ...clonedOptions\n    });\n  }\n\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], { ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n    execute_operation_1.executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: aggregateOperation.server,\n        session,\n        response\n      });\n    });\n  }\n\n  explain(verbosity, callback) {\n    if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n    if (verbosity == null) verbosity = true;\n    return execute_operation_1.executeOperation(this.topology, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], { ...this[kOptions],\n      ...this.cursorOptions,\n      explain: verbosity\n    }), callback);\n  }\n\n  group($group) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $group\n    });\n    return this;\n  }\n  /** Add a limit stage to the aggregation pipeline */\n\n\n  limit($limit) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $limit\n    });\n    return this;\n  }\n  /** Add a match stage to the aggregation pipeline */\n\n\n  match($match) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $match\n    });\n    return this;\n  }\n  /** Add an out stage to the aggregation pipeline */\n\n\n  out($out) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $out\n    });\n    return this;\n  }\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n\n\n  project($project) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $project\n    });\n    return this;\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n\n\n  lookup($lookup) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $lookup\n    });\n    return this;\n  }\n  /** Add a redact stage to the aggregation pipeline */\n\n\n  redact($redact) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $redact\n    });\n    return this;\n  }\n  /** Add a skip stage to the aggregation pipeline */\n\n\n  skip($skip) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $skip\n    });\n    return this;\n  }\n  /** Add a sort stage to the aggregation pipeline */\n\n\n  sort($sort) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $sort\n    });\n    return this;\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n\n\n  unwind($unwind) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $unwind\n    });\n    return this;\n  } // deprecated methods\n\n  /** @deprecated Add a geoNear stage to the aggregation pipeline */\n\n\n  geoNear($geoNear) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $geoNear\n    });\n    return this;\n  }\n\n}\n\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"sources":["../../src/cursor/aggregation_cursor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregationCursor = void 0;\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n    /** @internal */\n    constructor(topology, namespace, pipeline = [], options = {}) {\n        super(topology, namespace, options);\n        this[kPipeline] = pipeline;\n        this[kOptions] = options;\n    }\n    get pipeline() {\n        return this[kPipeline];\n    }\n    clone() {\n        const clonedOptions = utils_1.mergeOptions({}, this[kOptions]);\n        delete clonedOptions.session;\n        return new AggregationCursor(this.topology, this.namespace, this[kPipeline], {\n            ...clonedOptions\n        });\n    }\n    map(transform) {\n        return super.map(transform);\n    }\n    /** @internal */\n    _initialize(session, callback) {\n        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n            ...this[kOptions],\n            ...this.cursorOptions,\n            session\n        });\n        execute_operation_1.executeOperation(this.topology, aggregateOperation, (err, response) => {\n            if (err || response == null)\n                return callback(err);\n            // TODO: NODE-2882\n            callback(undefined, { server: aggregateOperation.server, session, response });\n        });\n    }\n    explain(verbosity, callback) {\n        if (typeof verbosity === 'function')\n            (callback = verbosity), (verbosity = true);\n        if (verbosity == null)\n            verbosity = true;\n        return execute_operation_1.executeOperation(this.topology, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n            ...this[kOptions],\n            ...this.cursorOptions,\n            explain: verbosity\n        }), callback);\n    }\n    group($group) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $group });\n        return this;\n    }\n    /** Add a limit stage to the aggregation pipeline */\n    limit($limit) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $limit });\n        return this;\n    }\n    /** Add a match stage to the aggregation pipeline */\n    match($match) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $match });\n        return this;\n    }\n    /** Add an out stage to the aggregation pipeline */\n    out($out) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $out });\n        return this;\n    }\n    /**\n     * Add a project stage to the aggregation pipeline\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n     * You should specify a parameterized type to have assertions on your final results.\n     *\n     * @example\n     * ```typescript\n     * // Best way\n     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * // Flexible way\n     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n     * ```\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling project,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n     *\n     * // or always use chaining and save the final cursor\n     *\n     * const cursor = coll.aggregate().project<{ a: string }>({\n     *   _id: 0,\n     *   a: { $convert: { input: '$a', to: 'string' }\n     * }});\n     * ```\n     */\n    project($project) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $project });\n        return this;\n    }\n    /** Add a lookup stage to the aggregation pipeline */\n    lookup($lookup) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $lookup });\n        return this;\n    }\n    /** Add a redact stage to the aggregation pipeline */\n    redact($redact) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $redact });\n        return this;\n    }\n    /** Add a skip stage to the aggregation pipeline */\n    skip($skip) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $skip });\n        return this;\n    }\n    /** Add a sort stage to the aggregation pipeline */\n    sort($sort) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $sort });\n        return this;\n    }\n    /** Add a unwind stage to the aggregation pipeline */\n    unwind($unwind) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $unwind });\n        return this;\n    }\n    // deprecated methods\n    /** @deprecated Add a geoNear stage to the aggregation pipeline */\n    geoNear($geoNear) {\n        abstract_cursor_1.assertUninitialized(this);\n        this[kPipeline].push({ $geoNear });\n        return this;\n    }\n}\nexports.AggregationCursor = AggregationCursor;\n//# sourceMappingURL=aggregation_cursor.js.map"]},"metadata":{},"sourceType":"script"}