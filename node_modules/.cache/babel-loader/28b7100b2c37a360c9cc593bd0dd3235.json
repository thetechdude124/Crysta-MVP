{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst commands_1 = require(\"./commands\");\n\nconst error_1 = require(\"../error\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst compression_1 = require(\"./wire_protocol/compression\");\n\nconst utils_1 = require(\"../utils\");\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\n\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\n\nclass MessageStream extends stream_1.Duplex {\n  constructor(options = {}) {\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read() {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compression_1.compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n}\n\nexports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  compression_1.decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}","map":{"version":3,"sources":["../../src/cmap/message_stream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageStream = void 0;\nconst stream_1 = require(\"stream\");\nconst commands_1 = require(\"./commands\");\nconst error_1 = require(\"../error\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst utils_1 = require(\"../utils\");\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nclass MessageStream extends stream_1.Duplex {\n    constructor(options = {}) {\n        super(options);\n        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n        this[kBuffer] = new utils_1.BufferPool();\n    }\n    _write(chunk, _, callback) {\n        this[kBuffer].append(chunk);\n        processIncomingData(this, callback);\n    }\n    _read( /* size */) {\n        // NOTE: This implementation is empty because we explicitly push data to be read\n        //       when `writeMessage` is called.\n        return;\n    }\n    writeCommand(command, operationDescription) {\n        // TODO: agreed compressor should live in `StreamDescription`\n        const compressorName = operationDescription && operationDescription.agreedCompressor\n            ? operationDescription.agreedCompressor\n            : 'none';\n        if (compressorName === 'none' || !canCompress(command)) {\n            const data = command.toBin();\n            this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n            return;\n        }\n        // otherwise, compress the message\n        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n        // Extract information needed for OP_COMPRESSED from the uncompressed message\n        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n        // Compress the message body\n        compression_1.compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n            if (err || !compressedMessage) {\n                operationDescription.cb(err);\n                return;\n            }\n            // Create the msgHeader of OP_COMPRESSED\n            const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n            msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n            msgHeader.writeInt32LE(command.requestId, 4); // requestID\n            msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n            msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n            // Create the compression details of OP_COMPRESSED\n            const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n            compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n            compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n            compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n            this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n        });\n    }\n}\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n    const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n    const commandName = Object.keys(commandDoc)[0];\n    return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n    const buffer = stream[kBuffer];\n    if (buffer.length < 4) {\n        callback();\n        return;\n    }\n    const sizeOfMessage = buffer.peek(4).readInt32LE();\n    if (sizeOfMessage < 0) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n        return;\n    }\n    if (sizeOfMessage > stream.maxBsonMessageSize) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n        return;\n    }\n    if (sizeOfMessage > buffer.length) {\n        callback();\n        return;\n    }\n    const message = buffer.read(sizeOfMessage);\n    const messageHeader = {\n        length: message.readInt32LE(0),\n        requestId: message.readInt32LE(4),\n        responseTo: message.readInt32LE(8),\n        opCode: message.readInt32LE(12)\n    };\n    let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n        const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n        stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n        if (buffer.length >= 4) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            callback();\n        }\n        return;\n    }\n    messageHeader.fromCompressed = true;\n    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n    const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n    // recalculate based on wrapped opcode\n    ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    compression_1.decompress(compressorID, compressedBuffer, (err, messageBody) => {\n        if (err || !messageBody) {\n            callback(err);\n            return;\n        }\n        if (messageBody.length !== messageHeader.length) {\n            callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n            return;\n        }\n        stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n        if (buffer.length >= 4) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            callback();\n        }\n    });\n}\n//# sourceMappingURL=message_stream.js.map"]},"metadata":{},"sourceType":"script"}