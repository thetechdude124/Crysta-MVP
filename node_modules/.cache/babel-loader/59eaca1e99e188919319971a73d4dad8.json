{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst bson_1 = require(\"../../bson\");\n\nconst error_1 = require(\"../../error\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst defaultAuthProviders_1 = require(\"./defaultAuthProviders\");\n\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n      utils_1.emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA1 : defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(utils_1.ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : deps_1.saslprep(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback( // TODO(NODE-3483)\n    new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command(utils_1.ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(utils_1.ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n\n}\n\nexports.ScramSHA1 = ScramSHA1;\n\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n\n}\n\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"sources":["../../../src/cmap/auth/scram.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst utils_1 = require(\"../../utils\");\nconst deps_1 = require(\"../../deps\");\nconst defaultAuthProviders_1 = require(\"./defaultAuthProviders\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n    constructor(cryptoMethod) {\n        super();\n        this.cryptoMethod = cryptoMethod || 'sha1';\n    }\n    prepare(handshakeDoc, authContext, callback) {\n        const cryptoMethod = this.cryptoMethod;\n        const credentials = authContext.credentials;\n        if (!credentials) {\n            return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n        }\n        if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n            utils_1.emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n        crypto.randomBytes(24, (err, nonce) => {\n            if (err) {\n                return callback(err);\n            }\n            // store the nonce for later use\n            Object.assign(authContext, { nonce });\n            const request = Object.assign({}, handshakeDoc, {\n                speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n                    db: credentials.source\n                })\n            });\n            callback(undefined, request);\n        });\n    }\n    auth(authContext, callback) {\n        const response = authContext.response;\n        if (response && response.speculativeAuthenticate) {\n            continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n            return;\n        }\n        executeScram(this.cryptoMethod, authContext, callback);\n    }\n}\nfunction cleanUsername(username) {\n    return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return Buffer.concat([\n        Buffer.from('n=', 'utf8'),\n        Buffer.from(username, 'utf8'),\n        Buffer.from(',r=', 'utf8'),\n        Buffer.from(nonce.toString('base64'), 'utf8')\n    ]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n    const username = cleanUsername(credentials.username);\n    const mechanism = cryptoMethod === 'sha1' ? defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA1 : defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return {\n        saslStart: 1,\n        mechanism,\n        payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n        autoAuthorize: 1,\n        options: { skipEmptyExchange: true }\n    };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n    connection.command(utils_1.ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n        const err = resolveError(_err, result);\n        if (err) {\n            return callback(err);\n        }\n        continueScramConversation(cryptoMethod, result, authContext, callback);\n    });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const username = cleanUsername(credentials.username);\n    const password = credentials.password;\n    let processedPassword;\n    if (cryptoMethod === 'sha256') {\n        processedPassword = 'kModuleError' in deps_1.saslprep ? password : deps_1.saslprep(password);\n    }\n    else {\n        try {\n            processedPassword = passwordDigest(username, password);\n        }\n        catch (e) {\n            return callback(e);\n        }\n    }\n    const payload = Buffer.isBuffer(response.payload)\n        ? new bson_1.Binary(response.payload)\n        : response.payload;\n    const dict = parsePayload(payload.value());\n    const iterations = parseInt(dict.i, 10);\n    if (iterations && iterations < 4096) {\n        callback(\n        // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n    }\n    const salt = dict.s;\n    const rnonce = dict.r;\n    if (rnonce.startsWith('nonce')) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n    }\n    // Set up start of proof\n    const withoutProof = `c=biws,r=${rnonce}`;\n    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n    const storedKey = H(cryptoMethod, clientKey);\n    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n    const clientProof = `p=${xor(clientKey, clientSignature)}`;\n    const clientFinal = [withoutProof, clientProof].join(',');\n    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n    const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: response.conversationId,\n        payload: new bson_1.Binary(Buffer.from(clientFinal))\n    };\n    connection.command(utils_1.ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n        const err = resolveError(_err, r);\n        if (err) {\n            return callback(err);\n        }\n        const parsedResponse = parsePayload(r.payload.value());\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n            return;\n        }\n        if (!r || r.done !== false) {\n            return callback(err, r);\n        }\n        const retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n        };\n        connection.command(utils_1.ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n    });\n}\nfunction parsePayload(payload) {\n    const dict = {};\n    const parts = payload.split(',');\n    for (let i = 0; i < parts.length; i++) {\n        const valueParts = parts[i].split('=');\n        dict[valueParts[0]] = valueParts[1];\n    }\n    return dict;\n}\nfunction passwordDigest(username, password) {\n    if (typeof username !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Username must be a string');\n    }\n    if (typeof password !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Password must be a string');\n    }\n    if (password.length === 0) {\n        throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n    }\n    const md5 = crypto.createHash('md5');\n    md5.update(`${username}:mongo:${password}`, 'utf8');\n    return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n    if (!Buffer.isBuffer(a)) {\n        a = Buffer.from(a);\n    }\n    if (!Buffer.isBuffer(b)) {\n        b = Buffer.from(b);\n    }\n    const length = Math.max(a.length, b.length);\n    const res = [];\n    for (let i = 0; i < length; i += 1) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n    return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n    return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n    _hiCache = {};\n    _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n    sha256: 32,\n    sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n    // omit the work if already generated\n    const key = [data, salt.toString('base64'), iterations].join('_');\n    if (_hiCache[key] != null) {\n        return _hiCache[key];\n    }\n    // generate the salt\n    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n    // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n    if (_hiCacheCount >= 200) {\n        _hiCachePurge();\n    }\n    _hiCache[key] = saltedData;\n    _hiCacheCount += 1;\n    return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n    if (lhs.length !== rhs.length) {\n        return false;\n    }\n    if (typeof crypto.timingSafeEqual === 'function') {\n        return crypto.timingSafeEqual(lhs, rhs);\n    }\n    let result = 0;\n    for (let i = 0; i < lhs.length; i++) {\n        result |= lhs[i] ^ rhs[i];\n    }\n    return result === 0;\n}\nfunction resolveError(err, result) {\n    if (err)\n        return err;\n    if (result) {\n        if (result.$err || result.errmsg)\n            return new error_1.MongoServerError(result);\n    }\n}\nclass ScramSHA1 extends ScramSHA {\n    constructor() {\n        super('sha1');\n    }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n    constructor() {\n        super('sha256');\n    }\n}\nexports.ScramSHA256 = ScramSHA256;\n//# sourceMappingURL=scram.js.map"]},"metadata":{},"sourceType":"script"}