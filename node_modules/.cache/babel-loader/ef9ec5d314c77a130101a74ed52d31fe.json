{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst error_1 = require(\"../error\");\n\nconst operation_1 = require(\"./operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst utils_2 = require(\"../utils\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(topology, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return utils_1.maybePromise(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n        executeOperation(topology, operation, cb);\n      });\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw e;\n    }\n  });\n}\n\nexports.executeOperation = executeOperation;\n\nfunction supportsRetryableReads(server) {\n  return utils_1.maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  if (session && session.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  const serverSelectionOptions = {\n    session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n\n    if (hasReadAspect && !error_1.isRetryableError(err) || hasWriteAspect && !itShouldRetryWrite) {\n      return callback(err);\n    }\n\n    if (hasWriteAspect && itShouldRetryWrite && err.code === MMAPv1_RETRY_WRITES_ERROR_CODE && err.errmsg.match(/Transaction numbers/)) {\n      callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError: err\n      }));\n      return;\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(readPreference, serverSelectionOptions, (e, server) => {\n      if (e || operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server) || operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !utils_2.supportsRetryableWrites(server)) {\n        callback(e);\n        return;\n      } // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n\n\n      if (err && err instanceof error_1.MongoNetworkError && server.loadBalanced && session && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && session && session.inTransaction()) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(readPreference, serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads !== false && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites === true && !inTransaction && utils_2.supportsRetryableWrites(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n\n    operation.execute(server, session, callback);\n  });\n}\n\nfunction shouldRetryWrite(err) {\n  return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}","map":{"version":3,"sources":["../../src/operations/execute_operation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeOperation = void 0;\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../utils\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(topology, operation, callback) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n    return utils_1.maybePromise(callback, cb => {\n        if (topology.shouldCheckForSessionSupport()) {\n            return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n                if (err)\n                    return cb(err);\n                executeOperation(topology, operation, cb);\n            });\n        }\n        // The driver sessions spec mandates that we implicitly create sessions for operations\n        // that are not explicitly provided with a session.\n        let session = operation.session;\n        let owner;\n        if (topology.hasSessionSupport()) {\n            if (session == null) {\n                owner = Symbol();\n                session = topology.startSession({ owner, explicit: false });\n            }\n            else if (session.hasEnded) {\n                return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n            }\n            else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n                return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n            }\n        }\n        else if (session) {\n            // If the user passed an explicit session and we are still, after server selection,\n            // trying to run against a topology that doesn't support sessions we error out.\n            return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n        }\n        try {\n            executeWithServerSelection(topology, session, operation, (err, result) => {\n                if (session && session.owner && session.owner === owner) {\n                    return session.endSession(err2 => cb(err2 || err, result));\n                }\n                cb(err, result);\n            });\n        }\n        catch (e) {\n            if (session && session.owner && session.owner === owner) {\n                session.endSession();\n            }\n            throw e;\n        }\n    });\n}\nexports.executeOperation = executeOperation;\nfunction supportsRetryableReads(server) {\n    return utils_1.maxWireVersion(server) >= 6;\n}\nfunction executeWithServerSelection(topology, session, operation, callback) {\n    const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n    const inTransaction = session && session.inTransaction();\n    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n        callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n        return;\n    }\n    if (session &&\n        session.isPinned &&\n        session.transaction.isCommitted &&\n        !operation.bypassPinningCheck) {\n        session.unpin();\n    }\n    const serverSelectionOptions = { session };\n    function callbackWithRetry(err, result) {\n        if (err == null) {\n            return callback(undefined, result);\n        }\n        const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n        const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n        const itShouldRetryWrite = shouldRetryWrite(err);\n        if ((hasReadAspect && !error_1.isRetryableError(err)) || (hasWriteAspect && !itShouldRetryWrite)) {\n            return callback(err);\n        }\n        if (hasWriteAspect &&\n            itShouldRetryWrite &&\n            err.code === MMAPv1_RETRY_WRITES_ERROR_CODE &&\n            err.errmsg.match(/Transaction numbers/)) {\n            callback(new error_1.MongoServerError({\n                message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                originalError: err\n            }));\n            return;\n        }\n        // select a new server, and attempt to retry the operation\n        topology.selectServer(readPreference, serverSelectionOptions, (e, server) => {\n            if (e ||\n                (operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server)) ||\n                (operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !utils_2.supportsRetryableWrites(server))) {\n                callback(e);\n                return;\n            }\n            // If we have a cursor and the initial command fails with a network error,\n            // we can retry it on another connection. So we need to check it back in, clear the\n            // pool for the service id, and retry again.\n            if (err &&\n                err instanceof error_1.MongoNetworkError &&\n                server.loadBalanced &&\n                session &&\n                session.isPinned &&\n                !session.inTransaction() &&\n                operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n                session.unpin({ force: true, forceClear: true });\n            }\n            operation.execute(server, session, callback);\n        });\n    }\n    if (readPreference &&\n        !readPreference.equals(read_preference_1.ReadPreference.primary) &&\n        session &&\n        session.inTransaction()) {\n        callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n        return;\n    }\n    // select a server, and execute the operation against it\n    topology.selectServer(readPreference, serverSelectionOptions, (err, server) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n            const willRetryRead = topology.s.options.retryReads !== false &&\n                !inTransaction &&\n                supportsRetryableReads(server) &&\n                operation.canRetryRead;\n            const willRetryWrite = topology.s.options.retryWrites === true &&\n                !inTransaction &&\n                utils_2.supportsRetryableWrites(server) &&\n                operation.canRetryWrite;\n            const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n            const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n            if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n                if (hasWriteAspect && willRetryWrite) {\n                    operation.options.willRetryWrite = true;\n                    session.incrementTransactionNumber();\n                }\n                operation.execute(server, session, callbackWithRetry);\n                return;\n            }\n        }\n        operation.execute(server, session, callback);\n    });\n}\nfunction shouldRetryWrite(err) {\n    return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}\n//# sourceMappingURL=execute_operation.js.map"]},"metadata":{},"sourceType":"script"}