{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\n\nconst server_description_1 = require(\"./server_description\");\n\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\n\nconst common_1 = require(\"./common\");\n\nconst error_1 = require(\"../error\"); // constants related to compatibility checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    var _a, _b;\n\n    options = options !== null && options !== void 0 ? options : {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n\n    if (setName) {\n      this.setName = setName;\n    }\n\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    } // determine server compatibility\n\n\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = undefined;\n\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n\n    for (const address of this.servers.keys()) {\n      if (newAddresses.has(address)) {\n        newAddresses.delete(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const [address, host] of newAddresses) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(host));\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // potentially mutated values\n\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new server_description_1.ServerDescription(address, undefined);\n    }\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nexports.TopologyDescription = TopologyDescription;\n\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n} // TODO: improve these docs when ObjectId is properly typed\n\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"sources":["../../src/sdam/topology_description.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TopologyDescription = void 0;\nconst server_description_1 = require(\"./server_description\");\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\nconst common_1 = require(\"./common\");\nconst error_1 = require(\"../error\");\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([\n    common_1.ServerType.RSSecondary,\n    common_1.ServerType.RSArbiter,\n    common_1.ServerType.RSOther\n]);\n/**\n * Representation of a deployment of servers\n * @public\n */\nclass TopologyDescription {\n    /**\n     * Create a TopologyDescription\n     */\n    constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n        var _a, _b;\n        options = options !== null && options !== void 0 ? options : {};\n        // TODO: consider assigning all these values to a temporary value `s` which\n        //       we use `Object.freeze` on, ensuring the internal state of this type\n        //       is immutable.\n        this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n        this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n        this.stale = false;\n        this.compatible = true;\n        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n        this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n        if (setName) {\n            this.setName = setName;\n        }\n        if (maxSetVersion) {\n            this.maxSetVersion = maxSetVersion;\n        }\n        if (maxElectionId) {\n            this.maxElectionId = maxElectionId;\n        }\n        if (commonWireVersion) {\n            this.commonWireVersion = commonWireVersion;\n        }\n        // determine server compatibility\n        for (const serverDescription of this.servers.values()) {\n            // Load balancer mode is always compatible.\n            if (serverDescription.type === common_1.ServerType.Unknown ||\n                serverDescription.type === common_1.ServerType.LoadBalancer) {\n                continue;\n            }\n            if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n            }\n            if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n                break;\n            }\n        }\n        // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n        // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n        // value among ServerDescriptions of all data-bearing server types. If any have a null\n        // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n        // set to null.\n        this.logicalSessionTimeoutMinutes = undefined;\n        for (const [, server] of this.servers) {\n            if (server.isReadable) {\n                if (server.logicalSessionTimeoutMinutes == null) {\n                    // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n                    this.logicalSessionTimeoutMinutes = undefined;\n                    break;\n                }\n                if (this.logicalSessionTimeoutMinutes == null) {\n                    // First server with a non null logicalSessionsTimeout\n                    this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n                    continue;\n                }\n                // Always select the smaller of the:\n                // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n                this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n            }\n        }\n    }\n    /**\n     * Returns a new TopologyDescription based on the SrvPollingEvent\n     * @internal\n     */\n    updateFromSrvPollingEvent(ev) {\n        const newAddresses = ev.addresses();\n        const serverDescriptions = new Map(this.servers);\n        for (const address of this.servers.keys()) {\n            if (newAddresses.has(address)) {\n                newAddresses.delete(address);\n            }\n            else {\n                serverDescriptions.delete(address);\n            }\n        }\n        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n            return this;\n        }\n        for (const [address, host] of newAddresses) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(host));\n        }\n        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     * @internal\n     */\n    update(serverDescription) {\n        const address = serverDescription.address;\n        // potentially mutated values\n        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n        if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n            serverDescription = new server_description_1.ServerDescription(address, undefined);\n        }\n        const serverType = serverDescription.type;\n        const serverDescriptions = new Map(this.servers);\n        // update common wire version\n        if (serverDescription.maxWireVersion !== 0) {\n            if (commonWireVersion == null) {\n                commonWireVersion = serverDescription.maxWireVersion;\n            }\n            else {\n                commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n            }\n        }\n        // update the actual server description\n        serverDescriptions.set(address, serverDescription);\n        if (topologyType === common_1.TopologyType.Single) {\n            // once we are defined as single, that never changes\n            return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n        }\n        if (topologyType === common_1.TopologyType.Unknown) {\n            if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n                serverDescriptions.delete(address);\n            }\n            else {\n                topologyType = topologyTypeForServerType(serverType);\n            }\n        }\n        if (topologyType === common_1.TopologyType.Sharded) {\n            if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n            if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n                topologyType = result[0];\n                setName = result[1];\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n            else if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n            }\n            else {\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n        }\n        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    get error() {\n        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);\n        if (descriptionsWithError.length > 0) {\n            return descriptionsWithError[0].error;\n        }\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n    get hasKnownServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n    get hasDataBearingServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);\n    }\n    /**\n     * Determines if the topology has a definition for the provided address\n     * @internal\n     */\n    hasServer(address) {\n        return this.servers.has(address);\n    }\n}\nexports.TopologyDescription = TopologyDescription;\nfunction topologyTypeForServerType(serverType) {\n    switch (serverType) {\n        case common_1.ServerType.Standalone:\n            return common_1.TopologyType.Single;\n        case common_1.ServerType.Mongos:\n            return common_1.TopologyType.Sharded;\n        case common_1.ServerType.RSPrimary:\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        case common_1.ServerType.RSOther:\n        case common_1.ServerType.RSSecondary:\n            return common_1.TopologyType.ReplicaSetNoPrimary;\n        default:\n            return common_1.TopologyType.Unknown;\n    }\n}\n// TODO: improve these docs when ObjectId is properly typed\nfunction compareObjectId(oid1, oid2) {\n    if (oid1 == null) {\n        return -1;\n    }\n    if (oid2 == null) {\n        return 1;\n    }\n    if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n        const oid1Buffer = oid1.id;\n        const oid2Buffer = oid2.id;\n        return oid1Buffer.compare(oid2Buffer);\n    }\n    const oid1String = oid1.toString();\n    const oid2String = oid2.toString();\n    return oid1String.localeCompare(oid2String);\n}\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n        if (maxSetVersion && maxElectionId) {\n            if (maxSetVersion > serverDescription.setVersion ||\n                compareObjectId(maxElectionId, electionId) > 0) {\n                // this primary is stale, we must remove it\n                serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n                return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n            }\n        }\n        maxElectionId = serverDescription.electionId;\n    }\n    if (serverDescription.setVersion != null &&\n        (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n        maxSetVersion = serverDescription.setVersion;\n    }\n    // We've heard from the primary. Is it the same primary as before?\n    for (const [address, server] of serverDescriptions) {\n        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n            // Reset old primary's type to Unknown.\n            serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));\n            // There can only be one primary\n            break;\n        }\n    }\n    // Discover new hosts from this primary's response.\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    // Remove hosts not in the response.\n    const currentAddresses = Array.from(serverDescriptions.keys());\n    const responseAddresses = serverDescription.allHosts;\n    currentAddresses\n        .filter((addr) => responseAddresses.indexOf(addr) === -1)\n        .forEach((address) => {\n        serverDescriptions.delete(address);\n    });\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    if (setName == null) {\n        // TODO(NODE-3483): should be an appropriate runtime error\n        throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n    }\n    if (setName !== serverDescription.setName ||\n        (serverDescription.me && serverDescription.address !== serverDescription.me)) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [topologyType, setName];\n    }\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n    for (const serverDescription of serverDescriptions.values()) {\n        if (serverDescription.type === common_1.ServerType.RSPrimary) {\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        }\n    }\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n}\n//# sourceMappingURL=topology_description.js.map"]},"metadata":{},"sourceType":"script"}