{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\n\nconst common_1 = require(\"../../sdam/common\");\n\nconst topology_description_1 = require(\"../../sdam/topology_description\");\n\nconst error_1 = require(\"../../error\");\n\nconst read_preference_1 = require(\"../../read_preference\");\n\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one\n\n  if (options === null || options === void 0 ? void 0 : options.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n\n  return readPreference;\n}\n\nexports.getReadPreference = getReadPreference;\n\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\n\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  } // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n\n\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n\n  return false;\n}\n\nexports.isSharded = isSharded;","map":{"version":3,"sources":["../../../src/cmap/wire_protocol/shared.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAcA,SAAgB,iBAAhB,CAAkC,GAAlC,EAAiD,OAAjD,EAA+E;AAC7E;AACA,MAAI,cAAc,GAAG,GAAG,CAAC,cAAJ,IAAsB,iBAAA,CAAA,cAAA,CAAe,OAA1D,CAF6E,CAG7E;;AACA,MAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,cAAb,EAA6B;AAC3B,IAAA,cAAc,GAAG,OAAO,CAAC,cAAzB;AACD;;AAED,MAAI,OAAO,cAAP,KAA0B,QAA9B,EAAwC;AACtC,IAAA,cAAc,GAAG,iBAAA,CAAA,cAAA,CAAe,UAAf,CAA0B,cAA1B,CAAjB;AACD;;AAED,MAAI,EAAE,cAAc,YAAY,iBAAA,CAAA,cAA5B,CAAJ,EAAiD;AAC/C,UAAM,IAAI,OAAA,CAAA,yBAAJ,CACJ,2DADI,CAAN;AAGD;;AAED,SAAO,cAAP;AACD;;AAnBD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAqBA,SAAgB,uBAAhB,CACE,YADF,EAEE,OAFF,EAEyB;AAEvB,EAAA,MAAM,CAAC,MAAP,CAAc,YAAd,EAA4B;AAC1B,IAAA,GAAG,EAAE,OAAO,OAAO,CAAC,GAAf,KAAuB,SAAvB,GAAmC,OAAO,CAAC,GAA3C,GAAiD,KAD5B;AAE1B,IAAA,YAAY,EAAE,OAAO,OAAO,CAAC,YAAf,KAAgC,SAAhC,GAA4C,OAAO,CAAC,YAApD,GAAmE,IAFvD;AAG1B,IAAA,aAAa,EAAE,OAAO,OAAO,CAAC,aAAf,KAAiC,SAAjC,GAA6C,OAAO,CAAC,aAArD,GAAqE,IAH1D;AAI1B,IAAA,cAAc,EAAE,OAAO,OAAO,CAAC,cAAf,KAAkC,SAAlC,GAA8C,OAAO,CAAC,cAAtD,GAAuE,KAJ7D;AAK1B,IAAA,UAAU,EAAE,OAAO,OAAO,CAAC,UAAf,KAA8B,SAA9B,GAA0C,OAAO,CAAC,UAAlD,GAA+D;AALjD,GAA5B;;AAQA,MAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,IAAA,YAAY,CAAC,OAAb,GAAuB,OAAO,CAAC,OAA/B;AACD;;AAED,SAAO,YAAP;AACD;;AAjBD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAmBA,SAAgB,SAAhB,CAA0B,gBAA1B,EAA0E;AACxE,MAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,CAA6B,IAA7B,KAAsC,QAAA,CAAA,UAAA,CAAW,MAArF,EAA6F;AAC3F,WAAO,IAAP;AACD,GAHuE,CAKxE;AACA;;;AACA,MAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,YAAwC,sBAAA,CAAA,mBAA5E,EAAiG;AAC/F,UAAM,OAAO,GAAwB,KAAK,CAAC,IAAN,CAAW,gBAAgB,CAAC,WAAjB,CAA6B,OAA7B,CAAqC,MAArC,EAAX,CAArC;AACA,WAAO,OAAO,CAAC,IAAR,CAAc,MAAD,IAA+B,MAAM,CAAC,IAAP,KAAgB,QAAA,CAAA,UAAA,CAAW,MAAvE,CAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAbD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\nconst common_1 = require(\"../../sdam/common\");\nconst topology_description_1 = require(\"../../sdam/topology_description\");\nconst error_1 = require(\"../../error\");\nconst read_preference_1 = require(\"../../read_preference\");\nfunction getReadPreference(cmd, options) {\n    // Default to command version of the readPreference\n    let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary;\n    // If we have an option readPreference override the command one\n    if (options === null || options === void 0 ? void 0 : options.readPreference) {\n        readPreference = options.readPreference;\n    }\n    if (typeof readPreference === 'string') {\n        readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    }\n    if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n        throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n    }\n    return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction applyCommonQueryOptions(queryOptions, options) {\n    Object.assign(queryOptions, {\n        raw: typeof options.raw === 'boolean' ? options.raw : false,\n        promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n        promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n        promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n        bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n    });\n    if (options.session) {\n        queryOptions.session = options.session;\n    }\n    return queryOptions;\n}\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\nfunction isSharded(topologyOrServer) {\n    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n        return true;\n    }\n    // NOTE: This is incredibly inefficient, and should be removed once command construction\n    //       happens based on `Server` not `Topology`.\n    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n        const servers = Array.from(topologyOrServer.description.servers.values());\n        return servers.some((server) => server.type === common_1.ServerType.Mongos);\n    }\n    return false;\n}\nexports.isSharded = isSharded;\n//# sourceMappingURL=shared.js.map"]},"metadata":{},"sourceType":"script"}