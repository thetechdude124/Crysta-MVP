{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\n\nconst net = require(\"net\");\n\nconst tls = require(\"tls\");\n\nconst connection_1 = require(\"./connection\");\n\nconst error_1 = require(\"../error\");\n\nconst defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst utils_1 = require(\"../utils\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst bson_1 = require(\"../bson\");\n\nconst FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' && process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\n\nfunction connect(options, callback) {\n  makeConnection(options, (err, socket) => {\n    var _a;\n\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(ismaster, options) {\n  var _a;\n\n  const serverVersionHighEnough = ismaster && (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) && ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) && ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(ismaster.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_1.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_1.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) && !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command(utils_1.ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if ('isWritablePrimary' in response) {\n        // Provide pre-hello-style response document.\n        response.ismaster = response.isWritablePrimary;\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        // TODO: Durran: Remove when server support exists. (NODE-3431)\n        if (FAKE_MONGODB_SERVICE_ID) {\n          response.serviceId = response.topologyVersion.processId;\n        }\n\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n\n        provider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster']: true,\n    helloOk: true,\n    client: options.metadata || utils_1.makeClientMetadata(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n/** @public */\n\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"sources":["../../src/cmap/connect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst connection_1 = require(\"./connection\");\nconst error_1 = require(\"../error\");\nconst defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst utils_1 = require(\"../utils\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst bson_1 = require(\"../bson\");\nconst FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' &&\n    process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\nfunction connect(options, callback) {\n    makeConnection(options, (err, socket) => {\n        var _a;\n        if (err || !socket) {\n            return callback(err);\n        }\n        let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n        if (options.autoEncrypter) {\n            ConnectionType = connection_1.CryptoConnection;\n        }\n        performInitialHandshake(new ConnectionType(socket, options), options, callback);\n    });\n}\nexports.connect = connect;\nfunction checkSupportedServer(ismaster, options) {\n    var _a;\n    const serverVersionHighEnough = ismaster &&\n        (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) &&\n        ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n    const serverVersionLowEnough = ismaster &&\n        (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) &&\n        ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    if (serverVersionHighEnough) {\n        if (serverVersionLowEnough) {\n            return null;\n        }\n        const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(ismaster.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_1.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MAX_SUPPORTED_SERVER_VERSION})`;\n        return new error_1.MongoCompatibilityError(message);\n    }\n    const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_1.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MIN_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n    const callback = function (err, ret) {\n        if (err && conn) {\n            conn.destroy();\n        }\n        _callback(err, ret);\n    };\n    const credentials = options.credentials;\n    if (credentials) {\n        if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) &&\n            !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n            callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n            return;\n        }\n    }\n    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n    prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n        if (err || !handshakeDoc) {\n            return callback(err);\n        }\n        const handshakeOptions = Object.assign({}, options);\n        if (typeof options.connectTimeoutMS === 'number') {\n            // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n            handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n        }\n        const start = new Date().getTime();\n        conn.command(utils_1.ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n                callback(new error_1.MongoServerError(response));\n                return;\n            }\n            if ('isWritablePrimary' in response) {\n                // Provide pre-hello-style response document.\n                response.ismaster = response.isWritablePrimary;\n            }\n            if (response.helloOk) {\n                conn.helloOk = true;\n            }\n            const supportedServerErr = checkSupportedServer(response, options);\n            if (supportedServerErr) {\n                callback(supportedServerErr);\n                return;\n            }\n            if (options.loadBalanced) {\n                // TODO: Durran: Remove when server support exists. (NODE-3431)\n                if (FAKE_MONGODB_SERVICE_ID) {\n                    response.serviceId = response.topologyVersion.processId;\n                }\n                if (!response.serviceId) {\n                    return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +\n                        'but the server does not support this mode.'));\n                }\n            }\n            // NOTE: This is metadata attached to the connection while porting away from\n            //       handshake being done in the `Server` class. Likely, it should be\n            //       relocated, or at very least restructured.\n            conn.ismaster = response;\n            conn.lastIsMasterMS = new Date().getTime() - start;\n            if (!response.arbiterOnly && credentials) {\n                // store the response on auth context\n                authContext.response = response;\n                const resolvedCredentials = credentials.resolveAuthMechanism(response);\n                const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n                if (!provider) {\n                    return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n                }\n                provider.auth(authContext, err => {\n                    if (err)\n                        return callback(err);\n                    callback(undefined, conn);\n                });\n                return;\n            }\n            callback(undefined, conn);\n        });\n    });\n}\nfunction prepareHandshakeDocument(authContext, callback) {\n    const options = authContext.options;\n    const compressors = options.compressors ? options.compressors : [];\n    const { serverApi } = authContext.connection;\n    const handshakeDoc = {\n        [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster']: true,\n        helloOk: true,\n        client: options.metadata || utils_1.makeClientMetadata(options),\n        compression: compressors,\n        loadBalanced: options.loadBalanced\n    };\n    const credentials = authContext.credentials;\n    if (credentials) {\n        if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n            handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n            const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n            if (!provider) {\n                // This auth mechanism is always present.\n                return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n            }\n            return provider.prepare(handshakeDoc, authContext, callback);\n        }\n        const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n        if (!provider) {\n            return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n        }\n        return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    callback(undefined, handshakeDoc);\n}\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = [\n    'ALPNProtocols',\n    'ca',\n    'cert',\n    'checkServerIdentity',\n    'ciphers',\n    'crl',\n    'ecdhCurve',\n    'key',\n    'minDHSize',\n    'passphrase',\n    'pfx',\n    'rejectUnauthorized',\n    'secureContext',\n    'secureProtocol',\n    'servername',\n    'session'\n];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = [\n    'family',\n    'hints',\n    'localAddress',\n    'localPort',\n    'lookup'\n];\nfunction parseConnectOptions(options) {\n    const hostAddress = options.hostAddress;\n    if (!hostAddress)\n        throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n    const result = {};\n    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (typeof hostAddress.socketPath === 'string') {\n        result.path = hostAddress.socketPath;\n        return result;\n    }\n    else if (typeof hostAddress.host === 'string') {\n        result.host = hostAddress.host;\n        result.port = hostAddress.port;\n        return result;\n    }\n    else {\n        // This should never happen since we set up HostAddresses\n        // But if we don't throw here the socket could hang until timeout\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n    }\n}\nfunction parseSslOptions(options) {\n    const result = parseConnectOptions(options);\n    // Merge in valid SSL options\n    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    // Set default sni servername to be the same as host\n    if (result.servername == null && result.host && !net.isIP(result.host)) {\n        result.servername = result.host;\n    }\n    return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n    const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n    const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n    const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n    const connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n    const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n    const keepAliveInitialDelay = (_j = (((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS\n        ? Math.round(socketTimeoutMS / 2)\n        : options.keepAliveInitialDelay)) !== null && _j !== void 0 ? _j : 120000;\n    let socket;\n    const callback = function (err, ret) {\n        if (err && socket) {\n            socket.destroy();\n        }\n        _callback(err, ret);\n    };\n    if (useTLS) {\n        const tlsSocket = tls.connect(parseSslOptions(options));\n        if (typeof tlsSocket.disableRenegotiation === 'function') {\n            tlsSocket.disableRenegotiation();\n        }\n        socket = tlsSocket;\n    }\n    else {\n        socket = net.createConnection(parseConnectOptions(options));\n    }\n    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n    socket.setTimeout(connectionTimeout);\n    socket.setNoDelay(noDelay);\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    let cancellationHandler;\n    function errorHandler(eventName) {\n        return (err) => {\n            SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n            if (cancellationHandler && options.cancellationToken) {\n                options.cancellationToken.removeListener('cancel', cancellationHandler);\n            }\n            socket.removeListener(connectEvent, connectHandler);\n            callback(connectionFailureError(eventName, err));\n        };\n    }\n    function connectHandler() {\n        SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n        if (cancellationHandler && options.cancellationToken) {\n            options.cancellationToken.removeListener('cancel', cancellationHandler);\n        }\n        if ('authorizationError' in socket) {\n            if (socket.authorizationError && rejectUnauthorized) {\n                return callback(socket.authorizationError);\n            }\n        }\n        socket.setTimeout(socketTimeoutMS);\n        callback(undefined, socket);\n    }\n    SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n    if (options.cancellationToken) {\n        cancellationHandler = errorHandler('cancel');\n        options.cancellationToken.once('cancel', cancellationHandler);\n    }\n    socket.once(connectEvent, connectHandler);\n}\nfunction connectionFailureError(type, err) {\n    switch (type) {\n        case 'error':\n            return new error_1.MongoNetworkError(err);\n        case 'timeout':\n            return new error_1.MongoNetworkTimeoutError('connection timed out');\n        case 'close':\n            return new error_1.MongoNetworkError('connection closed');\n        case 'cancel':\n            return new error_1.MongoNetworkError('connection establishment was cancelled');\n        default:\n            return new error_1.MongoNetworkError('unknown network error');\n    }\n}\n//# sourceMappingURL=connect.js.map"]},"metadata":{},"sourceType":"script"}