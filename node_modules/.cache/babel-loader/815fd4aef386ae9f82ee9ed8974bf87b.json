{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst utils_2 = require(\"./utils\");\n\nconst bson_1 = require(\"./bson\");\n\nconst error_1 = require(\"./error\");\n\nconst unordered_1 = require(\"./bulk/unordered\");\n\nconst ordered_1 = require(\"./bulk/ordered\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\n\nconst bulk_write_1 = require(\"./operations/bulk_write\");\n\nconst count_documents_1 = require(\"./operations/count_documents\");\n\nconst indexes_1 = require(\"./operations/indexes\");\n\nconst distinct_1 = require(\"./operations/distinct\");\n\nconst drop_1 = require(\"./operations/drop\");\n\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\n\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\n\nconst insert_1 = require(\"./operations/insert\");\n\nconst update_1 = require(\"./operations/update\");\n\nconst delete_1 = require(\"./operations/delete\");\n\nconst is_capped_1 = require(\"./operations/is_capped\");\n\nconst map_reduce_1 = require(\"./operations/map_reduce\");\n\nconst options_operation_1 = require(\"./operations/options_operation\");\n\nconst rename_1 = require(\"./operations/rename\");\n\nconst stats_1 = require(\"./operations/stats\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\n\n\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    var _a, _b;\n\n    utils_2.checkCollectionName(name); // Internal state\n\n    this.s = {\n      db,\n      options,\n      namespace: new utils_2.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: bson_1.resolveBSONOptions(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n\n\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n\n\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n\n\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n\n\n  get hint() {\n    return this.s.collectionHint;\n  }\n\n  set hint(v) {\n    this.s.collectionHint = utils_2.normalizeHintField(v);\n  }\n\n  insertOne(doc, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n    // we support that option style here only\n\n\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  insertMany(docs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {\n      ordered: true\n    };\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  bulkWrite(operations, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: true\n    };\n\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  updateOne(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  replaceOne(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  updateMany(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  deleteOne(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  deleteMany(filter, options, callback) {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  rename(newName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new rename_1.RenameOperation(this, newName, { ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }), callback);\n  }\n\n  drop(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n  }\n\n  findOne(filter, options, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n    const finalOptions = options !== null && options !== void 0 ? options : {};\n    return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n  }\n\n  find(filter, options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new find_cursor_1.FindCursor(utils_2.getTopology(this), this.s.namespace, filter, utils_1.resolveOptions(this, options));\n  }\n\n  options(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  isCapped(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  createIndex(indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  createIndexes(indexSpecs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  dropIndex(indexName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = utils_1.resolveOptions(this, options); // Run only against primary\n\n    options.readPreference = read_preference_1.ReadPreference.primary;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexOperation(this, indexName, options), callback);\n  }\n\n  dropIndexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n\n\n  listIndexes(options) {\n    return new indexes_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));\n  }\n\n  indexExists(indexes, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexExistsOperation(this, indexes, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  indexInformation(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  estimatedDocumentCount(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  countDocuments(filter, options, callback) {\n    if (filter == null) {\n      filter = {}, options = {}, callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  } // Implementation\n\n\n  distinct(key, filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  indexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new stats_1.CollStatsOperation(this, options), callback);\n  }\n\n  findOneAndDelete(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  findOneAndReplace(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  findOneAndUpdate(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n\n\n  aggregate(pipeline = [], options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n    }\n\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new aggregation_cursor_1.AggregationCursor(utils_2.getTopology(this), this.s.namespace, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @since 3.0.0\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n\n  mapReduce(map, reduce, options, callback) {\n    if ('function' === typeof options) callback = options, options = {}; // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n\n    if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n      throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new map_reduce_1.MapReduceOperation(this, map, reduce, utils_1.resolveOptions(this, options)), callback);\n  }\n  /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n\n\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n\n\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Get the db scoped logger */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n  get logger() {\n    return this.s.db.s.logger;\n  }\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead.\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  insert(docs, options, callback) {\n    utils_1.emitWarningOnce('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: false\n    };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  update(selector, update, options, callback) {\n    utils_1.emitWarningOnce('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.updateMany(selector, update, options, callback);\n  }\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  remove(selector, options, callback) {\n    utils_1.emitWarningOnce('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.deleteMany(selector, options, callback);\n  }\n\n  count(filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n}\n\nexports.Collection = Collection;","map":{"version":3,"sources":["../src/collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collection = void 0;\nconst utils_1 = require(\"./utils\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_2 = require(\"./utils\");\nconst bson_1 = require(\"./bson\");\nconst error_1 = require(\"./error\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst write_concern_1 = require(\"./write_concern\");\nconst read_concern_1 = require(\"./read_concern\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst insert_1 = require(\"./operations/insert\");\nconst update_1 = require(\"./operations/update\");\nconst delete_1 = require(\"./operations/delete\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst map_reduce_1 = require(\"./operations/map_reduce\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst stats_1 = require(\"./operations/stats\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nclass Collection {\n    /**\n     * Create a new Collection instance\n     * @internal\n     */\n    constructor(db, name, options) {\n        var _a, _b;\n        utils_2.checkCollectionName(name);\n        // Internal state\n        this.s = {\n            db,\n            options,\n            namespace: new utils_2.MongoDBNamespace(db.databaseName, name),\n            pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n            readPreference: read_preference_1.ReadPreference.fromOptions(options),\n            bsonOptions: bson_1.resolveBSONOptions(options, db),\n            readConcern: read_concern_1.ReadConcern.fromOptions(options),\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n            slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n        };\n    }\n    /**\n     * The name of the database this collection belongs to\n     */\n    get dbName() {\n        return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n    get collectionName() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n    get namespace() {\n        return this.s.namespace.toString();\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readConcern() {\n        if (this.s.readConcern == null) {\n            return this.s.db.readConcern;\n        }\n        return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readPreference() {\n        if (this.s.readPreference == null) {\n            return this.s.db.readPreference;\n        }\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get writeConcern() {\n        if (this.s.writeConcern == null) {\n            return this.s.db.writeConcern;\n        }\n        return this.s.writeConcern;\n    }\n    /** The current index hint for the collection */\n    get hint() {\n        return this.s.collectionHint;\n    }\n    set hint(v) {\n        this.s.collectionHint = utils_2.normalizeHintField(v);\n    }\n    insertOne(doc, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n        // we support that option style here only\n        if (options && Reflect.get(options, 'w')) {\n            options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)), callback);\n    }\n    insertMany(docs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : { ordered: true };\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options)), callback);\n    }\n    bulkWrite(operations, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: true };\n        if (!Array.isArray(operations)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options)), callback);\n    }\n    updateOne(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    replaceOne(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n    }\n    updateMany(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    deleteOne(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    deleteMany(filter, options, callback) {\n        if (filter == null) {\n            filter = {};\n            options = {};\n            callback = undefined;\n        }\n        else if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        else if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    rename(newName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        // Intentionally, we do not inherit options from parent for this operation.\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new rename_1.RenameOperation(this, newName, {\n            ...options,\n            readPreference: read_preference_1.ReadPreference.PRIMARY\n        }), callback);\n    }\n    drop(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n    }\n    findOne(filter, options, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n        }\n        if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n        const finalOptions = options !== null && options !== void 0 ? options : {};\n        return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n    }\n    find(filter, options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new find_cursor_1.FindCursor(utils_2.getTopology(this), this.s.namespace, filter, utils_1.resolveOptions(this, options));\n    }\n    options(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    isCapped(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    createIndex(indexSpec, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)), callback);\n    }\n    createIndexes(indexSpecs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : {};\n        if (typeof options.maxTimeMS !== 'number')\n            delete options.maxTimeMS;\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, options)), callback);\n    }\n    dropIndex(indexName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = utils_1.resolveOptions(this, options);\n        // Run only against primary\n        options.readPreference = read_preference_1.ReadPreference.primary;\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexOperation(this, indexName, options), callback);\n    }\n    dropIndexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n    listIndexes(options) {\n        return new indexes_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));\n    }\n    indexExists(indexes, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexExistsOperation(this, indexes, utils_1.resolveOptions(this, options)), callback);\n    }\n    indexInformation(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, utils_1.resolveOptions(this, options)), callback);\n    }\n    estimatedDocumentCount(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    countDocuments(filter, options, callback) {\n        if (filter == null) {\n            (filter = {}), (options = {}), (callback = undefined);\n        }\n        else if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 2) {\n                if (typeof options === 'function')\n                    (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    // Implementation\n    distinct(key, filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 3 && typeof options === 'function') {\n                (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    indexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    stats(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new stats_1.CollStatsOperation(this, options), callback);\n    }\n    findOneAndDelete(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    findOneAndReplace(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n    }\n    findOneAndUpdate(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n    aggregate(pipeline = [], options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n        }\n        if (!Array.isArray(pipeline)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new aggregation_cursor_1.AggregationCursor(utils_2.getTopology(this), this.s.namespace, pipeline, utils_1.resolveOptions(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @since 3.0.0\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n    }\n    mapReduce(map, reduce, options, callback) {\n        if ('function' === typeof options)\n            (callback = options), (options = {});\n        // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n        // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n        if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n            throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n        }\n        if ('function' === typeof map) {\n            map = map.toString();\n        }\n        if ('function' === typeof reduce) {\n            reduce = reduce.toString();\n        }\n        if ('function' === typeof options.finalize) {\n            options.finalize = options.finalize.toString();\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new map_reduce_1.MapReduceOperation(this, map, reduce, utils_1.resolveOptions(this, options)), callback);\n    }\n    /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n    initializeUnorderedBulkOp(options) {\n        return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));\n    }\n    /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n    initializeOrderedBulkOp(options) {\n        return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));\n    }\n    /** Get the db scoped logger */\n    getLogger() {\n        return this.s.db.s.logger;\n    }\n    get logger() {\n        return this.s.db.s.logger;\n    }\n    /**\n     * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @deprecated Use insertOne, insertMany or bulkWrite instead.\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    insert(docs, options, callback) {\n        utils_1.emitWarningOnce('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: false };\n        docs = !Array.isArray(docs) ? [docs] : docs;\n        if (options.keepGoing === true) {\n            options.ordered = false;\n        }\n        return this.insertMany(docs, options, callback);\n    }\n    /**\n     * Updates documents.\n     *\n     * @deprecated use updateOne, updateMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    update(selector, update, options, callback) {\n        utils_1.emitWarningOnce('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.updateMany(selector, update, options, callback);\n    }\n    /**\n     * Remove documents.\n     *\n     * @deprecated use deleteOne, deleteMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    remove(selector, options, callback) {\n        utils_1.emitWarningOnce('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.deleteMany(selector, options, callback);\n    }\n    count(filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (typeof options === 'function')\n                (callback = options), (options = {});\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n}\nexports.Collection = Collection;\n//# sourceMappingURL=collection.js.map"]},"metadata":{},"sourceType":"script"}