{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connect = exports.MONGO_CLIENT_EVENTS = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst topology_1 = require(\"../sdam/topology\");\n\nconst connection_string_1 = require(\"../connection_string\");\n\nconst connection_pool_1 = require(\"../cmap/connection_pool\");\n\nconst connection_1 = require(\"../cmap/connection\");\n\nconst server_1 = require(\"../sdam/server\");\n/** @public */\n\n\nexports.MONGO_CLIENT_EVENTS = [...connection_pool_1.CMAP_EVENTS, ...connection_1.APM_EVENTS, ...topology_1.TOPOLOGY_EVENTS, ...server_1.HEARTBEAT_EVENTS];\n\nfunction connect(mongoClient, options, callback) {\n  if (!callback) {\n    throw new error_1.MongoInvalidArgumentError('Callback function must be provided');\n  } // If a connection already been established, we can terminate early\n\n\n  if (mongoClient.topology && mongoClient.topology.isConnected()) {\n    return callback(undefined, mongoClient);\n  }\n\n  const logger = mongoClient.logger;\n\n  const connectCallback = err => {\n    const warningMessage = 'seed list contains no mongos proxies, replicaset connections requires ' + 'the parameter replicaSet to be supplied in the URI or options object, ' + 'mongodb://server:port/db?replicaSet=name';\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n      // TODO(NODE-3483)\n\n\n      return callback(new error_1.MongoRuntimeError(warningMessage));\n    }\n\n    callback(err, mongoClient);\n  };\n\n  if (typeof options.srvHost === 'string') {\n    return connection_string_1.resolveSRVRecord(options, (err, hosts) => {\n      if (err || !hosts) return callback(err);\n\n      for (const [index, host] of hosts.entries()) {\n        options.hosts[index] = host;\n      }\n\n      return createTopology(mongoClient, options, connectCallback);\n    });\n  }\n\n  return createTopology(mongoClient, options, connectCallback);\n}\n\nexports.connect = connect;\n\nfunction createTopology(mongoClient, options, callback) {\n  // Create the topology\n  const topology = new topology_1.Topology(options.hosts, options); // Events can be emitted before initialization is complete so we have to\n  // save the reference to the topology on the client ASAP if the event handlers need to access it\n\n  mongoClient.topology = topology;\n  topology.once(topology_1.Topology.OPEN, () => mongoClient.emit('open', mongoClient));\n\n  for (const event of exports.MONGO_CLIENT_EVENTS) {\n    topology.on(event, (...args) => mongoClient.emit(event, ...args));\n  } // initialize CSFLE if requested\n\n\n  if (mongoClient.autoEncrypter) {\n    mongoClient.autoEncrypter.init(err => {\n      if (err) {\n        return callback(err);\n      }\n\n      topology.connect(options, err => {\n        if (err) {\n          topology.close({\n            force: true\n          });\n          return callback(err);\n        }\n\n        options.encrypter.connectInternalClient(error => {\n          if (error) return callback(error);\n          callback(undefined, topology);\n        });\n      });\n    });\n    return;\n  } // otherwise connect normally\n\n\n  topology.connect(options, err => {\n    if (err) {\n      topology.close({\n        force: true\n      });\n      return callback(err);\n    }\n\n    callback(undefined, topology);\n    return;\n  });\n}","map":{"version":3,"sources":["../../src/operations/connect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.connect = exports.MONGO_CLIENT_EVENTS = void 0;\nconst error_1 = require(\"../error\");\nconst topology_1 = require(\"../sdam/topology\");\nconst connection_string_1 = require(\"../connection_string\");\nconst connection_pool_1 = require(\"../cmap/connection_pool\");\nconst connection_1 = require(\"../cmap/connection\");\nconst server_1 = require(\"../sdam/server\");\n/** @public */\nexports.MONGO_CLIENT_EVENTS = [\n    ...connection_pool_1.CMAP_EVENTS,\n    ...connection_1.APM_EVENTS,\n    ...topology_1.TOPOLOGY_EVENTS,\n    ...server_1.HEARTBEAT_EVENTS\n];\nfunction connect(mongoClient, options, callback) {\n    if (!callback) {\n        throw new error_1.MongoInvalidArgumentError('Callback function must be provided');\n    }\n    // If a connection already been established, we can terminate early\n    if (mongoClient.topology && mongoClient.topology.isConnected()) {\n        return callback(undefined, mongoClient);\n    }\n    const logger = mongoClient.logger;\n    const connectCallback = err => {\n        const warningMessage = 'seed list contains no mongos proxies, replicaset connections requires ' +\n            'the parameter replicaSet to be supplied in the URI or options object, ' +\n            'mongodb://server:port/db?replicaSet=name';\n        if (err && err.message === 'no mongos proxies found in seed list') {\n            if (logger.isWarn()) {\n                logger.warn(warningMessage);\n            }\n            // Return a more specific error message for MongoClient.connect\n            // TODO(NODE-3483)\n            return callback(new error_1.MongoRuntimeError(warningMessage));\n        }\n        callback(err, mongoClient);\n    };\n    if (typeof options.srvHost === 'string') {\n        return connection_string_1.resolveSRVRecord(options, (err, hosts) => {\n            if (err || !hosts)\n                return callback(err);\n            for (const [index, host] of hosts.entries()) {\n                options.hosts[index] = host;\n            }\n            return createTopology(mongoClient, options, connectCallback);\n        });\n    }\n    return createTopology(mongoClient, options, connectCallback);\n}\nexports.connect = connect;\nfunction createTopology(mongoClient, options, callback) {\n    // Create the topology\n    const topology = new topology_1.Topology(options.hosts, options);\n    // Events can be emitted before initialization is complete so we have to\n    // save the reference to the topology on the client ASAP if the event handlers need to access it\n    mongoClient.topology = topology;\n    topology.once(topology_1.Topology.OPEN, () => mongoClient.emit('open', mongoClient));\n    for (const event of exports.MONGO_CLIENT_EVENTS) {\n        topology.on(event, (...args) => mongoClient.emit(event, ...args));\n    }\n    // initialize CSFLE if requested\n    if (mongoClient.autoEncrypter) {\n        mongoClient.autoEncrypter.init(err => {\n            if (err) {\n                return callback(err);\n            }\n            topology.connect(options, err => {\n                if (err) {\n                    topology.close({ force: true });\n                    return callback(err);\n                }\n                options.encrypter.connectInternalClient(error => {\n                    if (error)\n                        return callback(error);\n                    callback(undefined, topology);\n                });\n            });\n        });\n        return;\n    }\n    // otherwise connect normally\n    topology.connect(options, err => {\n        if (err) {\n            topology.close({ force: true });\n            return callback(err);\n        }\n        callback(undefined, topology);\n        return;\n    });\n}\n//# sourceMappingURL=connect.js.map"]},"metadata":{},"sourceType":"script"}